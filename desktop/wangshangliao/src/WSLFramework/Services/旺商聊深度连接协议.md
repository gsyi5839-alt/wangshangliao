# 旺商聊深度连接协议完整解析

> 基于实际抓包和日志分析的真实协议文档
> 生成时间: 2026-01-11

---

## 一、网络架构

### 1.1 连接拓扑
```
┌─────────────┐     TCP:14745      ┌─────────────┐     HTTP API      ┌─────────────┐
│   ZCG机器人  │ ◄──────────────► │  xplugin框架 │ ◄──────────────► │  旺商聊服务器 │
│  (客户端)    │                   │  (中间层)    │                   │  (云端)      │
└─────────────┘                   └─────────────┘                   └─────────────┘
                                        │
                                        │ NIM SDK
                                        ▼
                                  ┌─────────────┐
                                  │  网易云信    │
                                  │  (IM服务)   │
                                  └─────────────┘
```

### 1.2 端口配置
| 用途 | 端口 | 协议 | 说明 |
|------|------|------|------|
| 本地通信 | 14745 | TCP | ZCG ↔ xplugin 通信 |
| 心跳检测 | 51234 | HTTP | 本地心跳服务 |
| NIM服务 | 443 | HTTPS | 网易云信API |

---

## 二、HTTP API 协议

### 2.1 公共请求头
```http
Content-Type: application/json
X-Device: 1
x-token: {认证Token}
x-id: {用户ID}
x-group-token: {群组Token}
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36
```

### 2.2 授权验证接口

**接口**: `POST /v1/plugins/activation-code`

**请求体**:
```json
{
  "type": "zcg2030",
  "token": "授权码16位",
  "user": "用户名"
}
```

**成功响应** (code=0):
```json
{
  "code": 0,
  "msg": "OK",
  "data": {}
}
```

**失败响应** (code≠0):
```json
{
  "code": 401,
  "msg": "无效的token或未登录",
  "line": 933,
  "file": "appx_context"
}
```

### 2.3 心跳检测接口

**接口**: `GET http://127.0.0.1:51234/ping`

**成功响应**:
```json
{
  "id": 0,
  "code": 0,
  "uid": 9502248
}
```

**失败响应**:
```json
{
  "id": 0,
  "code": 403,
  "errno": 50,
  "msg": "设备[0]掉线了!"
}
```

### 2.4 群禁言接口

**接口**: `POST /v1/group/set-group-mute`

**请求体**:
```json
{
  "groupId": 1176721,
  "muteMode": "MUTE_ALL"
}
```

**muteMode 取值**:
| 值 | 含义 |
|----|------|
| `MUTE_ALL` | 全员禁言 |
| `MUTE_NO` | 解除禁言 |

**成功响应**:
```json
{
  "code": 0,
  "msg": "OK",
  "data": {}
}
```

### 2.5 好友申请处理接口

**接口**: `POST /v1/plugins/handle-relation-ask-friend`

**请求体**:
```json
{
  "fromId": 7984877,
  "userId": 9502248,
  "state": "FRIENDLOG_STATE_AGREE"
}
```

**state 取值**:
| 值 | 含义 |
|----|------|
| `FRIENDLOG_STATE_AGREE` | 同意 |
| `FRIENDLOG_STATE_REFUSE` | 拒绝 |

### 2.6 ID查询接口

**接口**: `POST /v1/plugins/get-gid`

**请求体**:
```json
{
  "id": "324085447",
  "type": 2
}
```

**type 取值**:
| 值 | 含义 |
|----|------|
| 1 | 用户ID查询 |
| 2 | 群组ID查询 |

---

## 三、返回码定义

### 3.1 HTTP状态码
| 状态码 | 含义 |
|--------|------|
| 200 | 请求成功 |
| 400 | 请求参数错误 |
| 401 | 未授权/Token失效 |
| 403 | 权限不足 |
| 500 | 服务器内部错误 |

### 3.2 业务返回码 (code)
| code | 含义 | 处理方式 |
|------|------|----------|
| 0 | 成功 | 正常处理 |
| 401 | Token无效/未登录 | 重新登录 |
| 403 | 权限错误/设备掉线 | 检查状态 |
| 1001 | 业务错误(已处理过) | 忽略 |

### 3.3 错误码 (errno)
| errno | 含义 |
|-------|------|
| 50 | 设备掉线 |

---

## 四、本地TCP协议 (端口14745)

### 4.1 API调用格式

**通用格式**:
```
API名称|参数1|参数2|...|参数N
```

**返回格式**:
```
API名称|参数1|...|返回结果:Base64编码数据
```

### 4.2 完整API列表

#### 4.2.1 取绑定群
```
请求: 取绑定群|{机器人号}
返回: 取绑定群|{机器人号}|返回结果:{Base64}
```

#### 4.2.2 获取在线账号
```
请求: 云信_获取在线账号
返回: 云信_获取在线账号|返回结果:{Base64}
```

#### 4.2.3 发送群消息
```
请求: 发送群消息（文本）|{机器人号}|{内容}|{群号}|{类型}|{标志}
返回: 发送群消息（文本）|{机器人号}|{内容}|{群号}|{类型}|{标志}|返回结果:{Base64}

类型: 1=普通消息, 2=其他
标志: 0=正常发送
```

#### 4.2.4 发送私聊消息
```
请求: 发送好友消息|{机器人号}|{内容}|{目标号}
返回: 发送好友消息|{机器人号}|{内容}|{目标号}|返回结果:{Base64}
```

#### 4.2.5 群禁言控制
```
请求: ww_群禁言解禁|{机器人号}|{群号}|{动作}
返回: ww_群禁言解禁|{机器人号}|{群号}|{动作}|返回结果:{Base64}

动作: 1=禁言, 2=解禁
```

#### 4.2.6 修改群名片
```
请求: ww_改群名片|{机器人号}|{群号}|{用户号}|{新名片}
返回: ww_改群名片|{机器人号}|{群号}|{用户号}|{新名片}|返回结果:{Base64}
```

#### 4.2.7 获取群资料
```
请求: ww_获取群资料|{机器人号}|{群号}
返回: ww_获取群资料|{机器人号}|{群号}|返回结果:{Base64}
```

#### 4.2.8 ID互查
```
请求: ww_ID互查|{机器人号}|{旺商聊号}
返回: ww_ID互查|{机器人号}|{旺商聊号}|返回结果:{Base64}
```

#### 4.2.9 授权验证
```
请求: ww_xp限制接口|{状态}|{软件ID}|{授权码}|{用户名}|{时间1}|{时间2}
返回: ww_xp限制接口|{状态}|{软件ID}|{授权码}|{用户名}|{时间1}|{时间2}|返回结果:{Base64}

状态: 真/假
```

---

## 五、返回值解码

### 5.1 Base64解码方法

返回的Base64数据是**加密的二进制数据**，直接解码不可读：

```python
import base64

def decode_api_return(b64_str):
    """解码API返回值 - 返回原始字节"""
    try:
        return base64.b64decode(b64_str)
    except:
        return None
```

### 5.2 成功/失败判断

**方法1: 通过返回长度判断**
```python
def is_success(b64_result):
    """
    短返回通常表示简单成功
    长返回包含详细数据
    """
    decoded = base64.b64decode(b64_result)
    # 16字节以下通常是简单响应
    return len(decoded) <= 16
```

**方法2: 通过固定返回值对比**
```python
# 已知成功返回值
SUCCESS_RETURNS = {
    "TlllEPH6nt6j+I+wy69fZw==",  # 取绑定群成功
    "4PtLK0IVuLMRkWlrzZJH3w==",  # 发送消息成功
}

def is_known_success(b64_result):
    return b64_result in SUCCESS_RETURNS
```

### 5.3 已知返回值对照表

| Base64返回值 | 长度 | 含义 |
|-------------|------|------|
| `TlllEPH6nt6j+I+wy69fZw==` | 16字节 | 取绑定群成功(空) |
| `4PtLK0IVuLMRkWlrzZJH3w==` | 16字节 | 发送消息成功 |
| `iIEcyahRpLaUj9x+zriHjv0yoGMMK77efcp2lIzf0/Q=` | 32字节 | 授权验证成功 |
| 长Base64(>100字符) | 变长 | 包含数据的响应 |

---

## 六、NIM消息协议

### 6.1 消息JSON结构

```json
{
  "content": {
    "client_msg_id": "UUID消息ID",
    "server_msg_id": 2739491805904148336,
    "from_id": "1948408648",
    "from_nick": "发送者昵称(MD5)",
    "from_client_type": 16,
    "to_accid": "40821608989",
    "to_type": 1,
    "talk_id": "40821608989",
    "msg_type": 100,
    "msg_attach": "{\"b\":\"Base64Protobuf数据\"}",
    "msg_body": "",
    "msg_sub_type": 0,
    "time": 1768124458423,
    "offline_msg": 1,
    "push_enable": 1,
    "roam_msg": 1
  },
  "feature": 0,
  "rescode": 200
}
```

### 6.2 关键字段解析

| 字段 | 类型 | 说明 |
|------|------|------|
| `rescode` | int | NIM返回码，200=成功 |
| `to_type` | int | 0=私聊, 1=群聊 |
| `msg_type` | int | 0=文本, 100=自定义, 5=通知 |
| `msg_sub_type` | string | 消息子类型 |
| `from_client_type` | int | 16=PC, 2=iOS, 32=系统 |

### 6.3 消息子类型 (msg_sub_type)

| 值 | 含义 |
|----|------|
| `0` | 普通消息 |
| `NOTIFY_TYPE_GROUP_MUTE_1` | 群禁言开启 |
| `NOTIFY_TYPE_GROUP_MUTE_0` | 群禁言解除 |
| `NOTIFY_TYPE_USER_UPDATE_NAME` | 用户改名片 |

### 6.4 消息内容解码

消息内容在 `msg_attach.b` 字段中，是 **URL安全Base64编码的Protobuf数据**：

```python
import base64
import re

def decode_message_content(msg_attach):
    """
    解码消息内容
    输入: {"b":"URL安全Base64"}
    输出: (原始字节, 提取的文本)
    """
    import json
    
    attach = json.loads(msg_attach)
    b_content = attach.get('b', '')
    
    # URL安全Base64转标准Base64
    standard = b_content.replace('-', '+').replace('_', '/')
    padding = 4 - (len(standard) % 4)
    if padding < 4:
        standard += '=' * padding
    
    decoded = base64.b64decode(standard)
    
    # Protobuf结构: 头部(约12字节) + 数据
    # 尝试提取可读文本
    if len(decoded) > 12:
        payload = decoded[12:]
        text = payload.decode('utf-8', errors='ignore')
        # 清理不可打印字符
        clean = re.sub(r'[^\x20-\x7e\u4e00-\u9fff]', '', text)
        return decoded, clean
    
    return decoded, ""
```

---

## 七、插件投递格式

### 7.1 消息投递格式

当收到消息时，xplugin框架会以以下格式投递到ZCG：

```
机器人账号={robot_id}，主动账号={from_id}，被动账号={to_id}，群号={group_id}，内容={content}，消息ID={msg_id}，消息类型={msg_type}，消息时间={timestamp}，消息子类型={sub_type}，原始消息={raw_json}
```

### 7.2 字段对照表

| 插件字段 | NIM字段 | 说明 |
|---------|---------|------|
| 机器人账号 | - | 当前登录的机器人旺商聊号 |
| 主动账号 | from_id → 旺商聊号 | 发送者(需ID转换) |
| 被动账号 | to_accid → 旺商聊号 | 接收者(需ID转换) |
| 群号 | talk_id → 旺商聊群号 | 群号(需ID转换) |
| 内容 | msg_attach.b 解码 | 消息文本 |
| 消息类型 | msg_type映射 | 1001=私聊, 1002=群聊 |
| 消息时间 | time | 毫秒时间戳 |
| 消息子类型 | msg_sub_type | 事件子类型 |

### 7.3 消息类型映射

| 插件类型 | NIM to_type | 含义 |
|---------|-------------|------|
| 1001 | 0 | 私聊消息 |
| 1002 | 1 | 群聊消息 |
| 1003 | - | 系统通知 |
| 1015 | - | 好友申请 |

---

## 八、ID映射系统

### 8.1 双ID体系

旺商聊使用双ID体系：
- **旺商聊号**: 用户可见的账号(如 621705120)
- **NIM accid**: 网易云信内部ID(如 1948408648)

### 8.2 已知映射

| 旺商聊号 | NIM accid | 类型 |
|---------|-----------|------|
| 621705120 | 1948408648 | 机器人用户 |
| 781361487 | 1628907626 | 用户 |
| 324085447 | 1719936235 | 用户 |
| 3962369093 | 40821608989 | 群组 |

### 8.3 ID转换接口

使用 `ww_ID互查` API进行转换：
```
ww_ID互查|{机器人号}|{旺商聊号}
```

---

## 九、完整连接流程

### 9.1 初始化流程

```
1. 启动xplugin.exe (带授权参数)
   └─ xplugin.exe {Base64授权Token}

2. 加载插件 (Module.dll, zcg.dll等)

3. 授权验证
   └─ POST /v1/plugins/activation-code
   └─ 返回 code=0 表示成功

4. NIM SDK初始化
   └─ AppKey: 8a52a7cb1cff87c1e6ba5bfedc4c2e63
   └─ 连接云信服务器

5. 登录账号
   └─ accid: 1948408648 (对应621705120)

6. 启动心跳
   └─ 每60秒 GET /ping
   └─ 返回 code=0 表示在线

7. TCP服务就绪
   └─ 监听 127.0.0.1:14745
```

### 9.2 消息收发流程

**接收消息**:
```
1. NIM SDK收到消息
2. 解析JSON和Protobuf
3. ID转换 (NIM → 旺商聊)
4. 格式化为插件格式
5. 通过TCP发送到ZCG
```

**发送消息**:
```
1. ZCG通过TCP发送API调用
2. xplugin解析参数
3. ID转换 (旺商聊 → NIM)
4. 构造Protobuf
5. 通过NIM SDK发送
6. 返回Base64结果
```

---

## 十、Python实现示例

### 10.1 TCP客户端连接

```python
import socket
import threading
import time

class WangshangliaoClient:
    def __init__(self, host='127.0.0.1', port=14745):
        self.host = host
        self.port = port
        self.sock = None
        self.connected = False
        self.recv_buffer = b''
        
    def connect(self):
        """建立TCP连接"""
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((self.host, self.port))
            self.connected = True
            print(f"已连接到 {self.host}:{self.port}")
            return True
        except Exception as e:
            print(f"连接失败: {e}")
            return False
    
    def send_api(self, api_call):
        """发送API调用"""
        if not self.connected:
            return None
        try:
            # 添加换行符作为消息分隔
            data = (api_call + '\n').encode('utf-8')
            self.sock.send(data)
            return self.recv_response()
        except Exception as e:
            print(f"发送失败: {e}")
            return None
    
    def recv_response(self, timeout=5):
        """接收响应"""
        self.sock.settimeout(timeout)
        try:
            data = self.sock.recv(4096)
            return data.decode('utf-8', errors='ignore')
        except socket.timeout:
            return None
    
    def get_online_accounts(self):
        """获取在线账号"""
        return self.send_api("云信_获取在线账号")
    
    def get_bind_groups(self, robot_id):
        """获取绑定群"""
        return self.send_api(f"取绑定群|{robot_id}")
    
    def send_group_message(self, robot_id, content, group_id):
        """发送群消息"""
        content = content.replace('\n', '\\n')
        return self.send_api(f"发送群消息（文本）|{robot_id}|{content}|{group_id}|1|0")
    
    def send_private_message(self, robot_id, content, target_id):
        """发送私聊消息"""
        content = content.replace('\n', '\\n')
        return self.send_api(f"发送好友消息|{robot_id}|{content}|{target_id}")
    
    def group_mute(self, robot_id, group_id, mute=True):
        """群禁言"""
        action = "1" if mute else "2"
        return self.send_api(f"ww_群禁言解禁|{robot_id}|{group_id}|{action}")
    
    def close(self):
        """关闭连接"""
        if self.sock:
            self.sock.close()
            self.connected = False
```

### 10.2 返回值解析

```python
import base64
import re

class ResponseParser:
    # 已知成功返回值
    KNOWN_SUCCESS = {
        "TlllEPH6nt6j+I+wy69fZw==",
        "4PtLK0IVuLMRkWlrzZJH3w==",
    }
    
    @classmethod
    def parse_response(cls, response):
        """
        解析API响应
        返回: (成功?, API名称, 参数列表, Base64结果)
        """
        if not response:
            return False, None, [], None
        
        # 提取返回结果
        match = re.search(r'返回结果:(.+?)(?:\n|$)', response)
        if match:
            b64_result = match.group(1).strip()
            parts = response.split('|')
            api_name = parts[0] if parts else None
            params = parts[1:-1] if len(parts) > 2 else []
            
            success = cls.is_success(b64_result)
            return success, api_name, params, b64_result
        
        return False, None, [], None
    
    @classmethod
    def is_success(cls, b64_result):
        """判断是否成功"""
        if b64_result in cls.KNOWN_SUCCESS:
            return True
        try:
            decoded = base64.b64decode(b64_result)
            # 短响应通常是成功
            return len(decoded) <= 32
        except:
            return False
    
    @classmethod
    def decode_result(cls, b64_result):
        """解码返回值"""
        try:
            return base64.b64decode(b64_result)
        except:
            return None
```

### 10.3 消息内容解码

```python
import json
import base64
import re

class MessageDecoder:
    @staticmethod
    def decode_msg_attach(msg_attach_str):
        """
        解码消息附件
        输入: '{"b":"URL安全Base64"}'
        输出: (原始字节, 文本内容)
        """
        try:
            attach = json.loads(msg_attach_str)
            b_content = attach.get('b', '')
            
            # URL安全Base64转标准Base64
            standard = b_content.replace('-', '+').replace('_', '/')
            padding = 4 - (len(standard) % 4)
            if padding < 4:
                standard += '=' * padding
            
            decoded = base64.b64decode(standard)
            
            # 提取可读文本 (跳过Protobuf头部)
            text = ""
            if len(decoded) > 12:
                payload = decoded[12:]
                raw_text = payload.decode('utf-8', errors='ignore')
                # 提取中英文和数字
                text = re.sub(r'[^\x20-\x7e\u4e00-\u9fff\n]', '', raw_text)
            
            return decoded, text.strip()
            
        except Exception as e:
            return None, f"解码错误: {e}"
    
    @staticmethod
    def parse_plugin_message(text):
        """
        解析插件投递的消息
        """
        pattern = re.compile(
            r'机器人账号=([^，]*)，'
            r'主动账号=([^，]*)，'
            r'被动账号=([^，]*)，'
            r'群号=([^，]*)，'
            r'内容=([^，]*)，'
            r'消息ID=([^，]+)，'
            r'消息类型=([^，]+)，'
            r'消息时间=([^，]+)，'
            r'消息子类型=([^，]+)，'
            r'原始消息=(.*)',
            re.DOTALL
        )
        
        match = pattern.search(text)
        if match:
            return {
                'robot_id': match.group(1),
                'from_id': match.group(2),
                'to_id': match.group(3),
                'group_id': match.group(4),
                'content': match.group(5),
                'msg_id': match.group(6),
                'msg_type': match.group(7),
                'msg_time': match.group(8),
                'msg_sub_type': match.group(9),
                'raw_json': match.group(10)
            }
        return None
```

---

## 十一、错误处理

### 11.1 连接错误

| 错误 | 原因 | 解决方案 |
|------|------|----------|
| 连接拒绝 | xplugin未启动 | 先启动xplugin.exe |
| 连接超时 | 端口被占用 | 检查14745端口 |
| 连接中断 | 程序崩溃 | 重启程序 |

### 11.2 API错误

| 返回码 | 原因 | 解决方案 |
|--------|------|----------|
| code=401 | Token失效 | 重新登录 |
| code=403 | 设备掉线 | 检查网络 |
| code=1001 | 重复操作 | 忽略 |
| errno=50 | 账号掉线 | 重连 |

---

## 十二、附录

### 12.1 常用端点汇总

| 端点 | 方法 | 用途 |
|------|------|------|
| `/v1/plugins/activation-code` | POST | 授权验证 |
| `/v1/group/set-group-mute` | POST | 群禁言 |
| `/v1/plugins/handle-relation-ask-friend` | POST | 好友申请 |
| `/v1/plugins/get-gid` | POST | ID查询 |
| `/ping` | GET | 心跳检测 |

### 12.2 NIM AppKey

```
AppKey: 8a52a7cb1cff87c1e6ba5bfedc4c2e63
```

### 12.3 消息类型对照

| msg_type | 名称 | 说明 |
|----------|------|------|
| 0 | TEXT | 文本消息 |
| 1 | IMAGE | 图片消息 |
| 2 | VOICE | 语音消息 |
| 5 | NOTIFICATION | 通知消息 |
| 100 | CUSTOM | 自定义消息 |

---

## 十三、禁言/解禁协议深度解析

### 13.1 禁言API完整流程

```
┌──────────┐    TCP调用     ┌──────────┐    HTTP POST    ┌──────────┐
│  ZCG机器人 │ ──────────► │  xplugin  │ ─────────────► │ 旺商聊服务器│
│           │              │           │                │           │
│ ww_群禁言解禁│             │ /v1/group/│                │  处理请求  │
│ |机器人|群|1│             │ set-group-│                │           │
└──────────┘              │ mute      │                └──────────┘
      ▲                    └──────────┘                      │
      │                         │                            │
      │    Base64返回结果        │      JSON响应              │
      └─────────────────────────┴────────────────────────────┘
```

### 13.2 本地TCP禁言命令

**禁言命令格式**:
```
ww_群禁言解禁|{机器人号}|{群号}|{动作}
```

**参数说明**:
| 参数 | 类型 | 说明 |
|------|------|------|
| 机器人号 | string | 旺商聊机器人账号，如 `621705120` |
| 群号 | string | 旺商聊群号，如 `3962369093` |
| 动作 | int | `1`=禁言, `2`=解禁 |

**实际调用示例**:
```
# 禁言
ww_群禁言解禁|621705120|3962369093|1

# 解禁
ww_群禁言解禁|621705120|3962369093|2
```

**返回格式**:
```
ww_群禁言解禁|621705120|3962369093|1|返回结果:iIEcyahRpLaUj9x+zriHjm1S4/uHjzwXxIvTKtsxAjWRDmEkKr+/mNOeaxfIZl28
```

### 13.3 HTTP API详细协议

**接口**: `POST /v1/group/set-group-mute`

**请求头**:
```http
Content-Type: application/json
x-token: {认证Token}
X-Device: 1
x-id: {用户ID}
x-group-token: {群组Token}
```

**请求体 - 禁言**:
```json
{
  "groupId": 1176721,
  "muteMode": "MUTE_MEMBER"
}
```

**请求体 - 全员禁言**:
```json
{
  "groupId": 1176721,
  "muteMode": "MUTE_ALL"
}
```

**请求体 - 解禁**:
```json
{
  "groupId": 1176721,
  "muteMode": "MUTE_NO"
}
```

**muteMode 完整取值**:
| 值 | 含义 | 说明 |
|----|------|------|
| `MUTE_ALL` | 全员禁言 | 除管理员外全部禁言 |
| `MUTE_MEMBER` | 成员禁言 | 指定成员禁言 |
| `MUTE_NO` | 解除禁言 | 解除全员禁言 |

### 13.4 返回值解析

**成功响应**:
```json
{
  "code": 0,
  "msg": "OK",
  "data": {}
}
```

**失败响应 - Token无效**:
```json
{
  "code": 401,
  "msg": "无效的token或未登录",
  "line": 933,
  "file": "appx_context"
}
```

**Base64返回值对照**:
| 场景 | Base64返回值 | 解码含义 |
|------|-------------|----------|
| 禁言成功 | `iIEcyahRpLaUj9x+zriHjm1S4/uHjzwXxIvTKtsxAjWRDmEkKr+/mNOeaxfIZl28` | 加密的成功标识 |
| 无Token失败 | `8H6fOpMKYldD2IzCr5hZlzRM0jehME4V4C5akb0PKks3Q3jlcMQ9PLJrTThFlP77CFh7EDDdqGUQYhgG7suJTumSbRWtJzwMEktqaq5ugsu4iEUULSWLtMvqc5jbLxid5AKHxjbDoNJmZAl+wLJ94Q==` | Token校验失败 |

### 13.5 禁言通知消息

当群禁言状态改变时，NIM会推送通知消息：

**禁言开启通知**:
```
消息子类型: NOTIFY_TYPE_GROUP_MUTE_1
消息类型: 1002 (群消息)
msg_type: 5 (通知消息)
```

**禁言解除通知**:
```
消息子类型: NOTIFY_TYPE_GROUP_MUTE_0
消息类型: 1002 (群消息)
msg_type: 5 (通知消息)
```

### 13.6 NIM通知消息结构

**完整的禁言通知JSON**:
```json
{
  "content": {
    "client_msg_id": "ab729665-6b06-4f7d-a814-a59d3595b1fa",
    "from_client_type": 32,
    "from_id": "1948408648",
    "from_nick": "a4ece45c6b12086f4e82bac509caec3d",
    "log_status": 2,
    "msg_type": 5,
    "msg_attach": "{...team_info...}",
    "talk_id": "40821608989",
    "to_accid": "40821608989",
    "to_type": 1,
    "time": 1768112829571
  },
  "rescode": 200
}
```

**msg_attach中的team_info结构**:
```json
{
  "data": {
    "name_cards": [
      {
        "accid": "1948408648",
        "name": "d153f4e86e8c0eda3867e842e507cd93",
        "icon": "791610986162052788",
        "ex": "{\"nickname_ciphertext\":\"mtmQz6FQ9lG6P3ZaOPXWrg==\"}"
      }
    ],
    "team_info": {
      "mute_all": 1,
      "mute_type": 1,
      "tid": "40821608989",
      "update_timetag": 1768112829565
    }
  },
  "id": 3
}
```

**team_info字段解析**:
| 字段 | 禁言状态值 | 解禁状态值 | 说明 |
|------|-----------|-----------|------|
| `mute_all` | 1 | 0 | 是否全员禁言 |
| `mute_type` | 1 | 0 | 禁言类型 |
| `tid` | 群NIM ID | 群NIM ID | 群组标识 |
| `update_timetag` | 时间戳 | 时间戳 | 更新时间(毫秒) |

### 13.7 判断禁言成功的方法

**方法1: 检查返回值长度**
```python
def is_mute_success(b64_result):
    """
    禁言成功的返回值通常是固定长度
    """
    import base64
    try:
        decoded = base64.b64decode(b64_result)
        # 成功返回通常是48-64字节
        return 40 <= len(decoded) <= 70
    except:
        return False
```

**方法2: 监听禁言通知**
```python
def on_message(msg):
    """
    通过监听禁言通知确认状态
    """
    if msg.get('msg_sub_type') == 'NOTIFY_TYPE_GROUP_MUTE_1':
        # 禁言成功
        team_info = parse_team_info(msg['msg_attach'])
        if team_info['mute_all'] == 1:
            return True, "禁言成功"
    
    elif msg.get('msg_sub_type') == 'NOTIFY_TYPE_GROUP_MUTE_0':
        # 解禁成功
        team_info = parse_team_info(msg['msg_attach'])
        if team_info['mute_all'] == 0:
            return True, "解禁成功"
    
    return False, "状态未知"
```

### 13.8 完整Python实现

```python
import socket
import base64
import json
import re

class MuteController:
    """禁言控制器"""
    
    def __init__(self, host='127.0.0.1', port=14745):
        self.host = host
        self.port = port
        self.sock = None
        
    def connect(self):
        """连接到xplugin"""
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((self.host, self.port))
        self.sock.settimeout(10)
        return True
    
    def mute_group(self, robot_id: str, group_id: str) -> tuple:
        """
        禁言群组
        返回: (成功?, Base64结果, 错误信息)
        """
        cmd = f"ww_群禁言解禁|{robot_id}|{group_id}|1\n"
        return self._send_and_parse(cmd)
    
    def unmute_group(self, robot_id: str, group_id: str) -> tuple:
        """
        解禁群组
        返回: (成功?, Base64结果, 错误信息)
        """
        cmd = f"ww_群禁言解禁|{robot_id}|{group_id}|2\n"
        return self._send_and_parse(cmd)
    
    def _send_and_parse(self, cmd: str) -> tuple:
        """发送命令并解析响应"""
        try:
            self.sock.send(cmd.encode('utf-8'))
            response = self.sock.recv(4096).decode('utf-8', errors='ignore')
            
            # 提取Base64返回值
            match = re.search(r'返回结果:(.+?)(?:\n|$)', response)
            if match:
                b64_result = match.group(1).strip()
                success = self._check_success(b64_result)
                return success, b64_result, None
            
            return False, None, "无返回结果"
            
        except Exception as e:
            return False, None, str(e)
    
    def _check_success(self, b64_result: str) -> bool:
        """检查是否成功"""
        try:
            decoded = base64.b64decode(b64_result)
            # 成功返回通常是48-64字节的加密数据
            return 40 <= len(decoded) <= 70
        except:
            return False
    
    def close(self):
        """关闭连接"""
        if self.sock:
            self.sock.close()


class MuteNotificationParser:
    """禁言通知解析器"""
    
    @staticmethod
    def parse(msg_text: str) -> dict:
        """
        解析禁言/解禁通知
        返回: {
            'event': 'mute'/'unmute',
            'group_id': 群号,
            'operator': 操作者,
            'timestamp': 时间戳
        }
        """
        result = {
            'event': None,
            'group_id': None,
            'operator': None,
            'timestamp': None
        }
        
        # 检测禁言事件
        if 'NOTIFY_TYPE_GROUP_MUTE_1' in msg_text:
            result['event'] = 'mute'
        elif 'NOTIFY_TYPE_GROUP_MUTE_0' in msg_text:
            result['event'] = 'unmute'
        else:
            return result
        
        # 提取群号
        group_match = re.search(r'群号=(\d+)', msg_text)
        if group_match:
            result['group_id'] = group_match.group(1)
        
        # 提取team_info
        try:
            # 找到msg_attach中的JSON
            attach_match = re.search(r'"msg_attach":\s*"([^"]+)"', msg_text)
            if attach_match:
                attach_str = attach_match.group(1)
                # 反转义
                attach_str = attach_str.replace('\\n', '\n').replace('\\t', '\t').replace('\\"', '"')
                attach = json.loads(attach_str)
                
                team_info = attach.get('data', {}).get('team_info', {})
                result['mute_all'] = team_info.get('mute_all')
                result['mute_type'] = team_info.get('mute_type')
                result['timestamp'] = team_info.get('update_timetag')
                
        except Exception as e:
            pass
        
        return result


# 使用示例
if __name__ == '__main__':
    # 禁言示例
    controller = MuteController()
    if controller.connect():
        # 禁言
        success, result, error = controller.mute_group('621705120', '3962369093')
        print(f"禁言: 成功={success}, 结果={result}")
        
        # 解禁
        success, result, error = controller.unmute_group('621705120', '3962369093')
        print(f"解禁: 成功={success}, 结果={result}")
        
        controller.close()
```

### 13.9 ID转换说明

**禁言时需要的ID**:
- 本地TCP调用使用**旺商聊号**
- HTTP API使用**旺商聊groupId**(数字ID)
- NIM通知中的tid是**NIM群组ID**

**ID映射示例**:
| 旺商聊群号 | 旺商聊groupId | NIM tid |
|-----------|--------------|---------|
| 3962369093 | 1176721 | 40821608989 |

### 13.10 错误处理

| 错误码 | 含义 | 解决方案 |
|--------|------|----------|
| 401 | Token无效/未登录 | 重新登录获取token |
| 403 | 无权限 | 检查是否为群管理员 |
| 404 | 群不存在 | 检查群号是否正确 |
| 500 | 服务器错误 | 稍后重试 |

---

*文档版本: 1.1*
*更新: 添加禁言/解禁完整协议*
*基于实际抓包分析*
