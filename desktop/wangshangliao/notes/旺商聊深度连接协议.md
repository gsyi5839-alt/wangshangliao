# 旺商聊深度连接协议完整解析

> 基于实际抓包和日志分析的真实协议文档
> 生成时间: 2026-01-11

---

## 一、网络架构

### 1.1 连接拓扑
```
┌─────────────┐     TCP:14745      ┌─────────────┐     HTTP API      ┌─────────────┐
│   ZCG机器人  │ ◄──────────────► │  xplugin框架 │ ◄──────────────► │  旺商聊服务器 │
│  (客户端)    │                   │  (中间层)    │                   │  (云端)      │
└─────────────┘                   └─────────────┘                   └─────────────┘
                                        │
                                        │ NIM SDK
                                        ▼
                                  ┌─────────────┐
                                  │  网易云信    │
                                  │  (IM服务)   │
                                  └─────────────┘
```

### 1.2 端口配置
| 用途 | 端口 | 协议 | 说明 |
|------|------|------|------|
| 本地通信 | 14745 | TCP | ZCG ↔ xplugin 通信 |
| 心跳检测 | 51234 | HTTP | 本地心跳服务 |
| NIM服务 | 443 | HTTPS | 网易云信API |

---

## 二、HTTP API 协议

### 2.1 公共请求头
```http
Content-Type: application/json
X-Device: 1
x-token: {认证Token}
x-id: {用户ID}
x-group-token: {群组Token}
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36
```

### 2.2 授权验证接口

**接口**: `POST /v1/plugins/activation-code`

**请求体**:
```json
{
  "type": "zcg2030",
  "token": "授权码16位",
  "user": "用户名"
}
```

**成功响应** (code=0):
```json
{
  "code": 0,
  "msg": "OK",
  "data": {}
}
```

**失败响应** (code≠0):
```json
{
  "code": 401,
  "msg": "无效的token或未登录",
  "line": 933,
  "file": "appx_context"
}
```

### 2.3 心跳检测接口

**接口**: `GET http://127.0.0.1:51234/ping`

**成功响应**:
```json
{
  "id": 0,
  "code": 0,
  "uid": 9502248
}
```

**失败响应**:
```json
{
  "id": 0,
  "code": 403,
  "errno": 50,
  "msg": "设备[0]掉线了!"
}
```

### 2.4 群禁言接口

**接口**: `POST /v1/group/set-group-mute`

**请求体**:
```json
{
  "groupId": 1176721,
  "muteMode": "MUTE_ALL"
}
```

**muteMode 取值**:
| 值 | 含义 |
|----|------|
| `MUTE_ALL` | 全员禁言 |
| `MUTE_NO` | 解除禁言 |

**成功响应**:
```json
{
  "code": 0,
  "msg": "OK",
  "data": {}
}
```

### 2.5 好友申请处理接口

**接口**: `POST /v1/plugins/handle-relation-ask-friend`

**请求体**:
```json
{
  "fromId": 7984877,
  "userId": 9502248,
  "state": "FRIENDLOG_STATE_AGREE"
}
```

**state 取值**:
| 值 | 含义 |
|----|------|
| `FRIENDLOG_STATE_AGREE` | 同意 |
| `FRIENDLOG_STATE_REFUSE` | 拒绝 |

### 2.6 ID查询接口

**接口**: `POST /v1/plugins/get-gid`

**请求体**:
```json
{
  "id": "324085447",
  "type": 2
}
```

**type 取值**:
| 值 | 含义 |
|----|------|
| 1 | 用户ID查询 |
| 2 | 群组ID查询 |

---

## 三、返回码定义

### 3.1 HTTP状态码
| 状态码 | 含义 |
|--------|------|
| 200 | 请求成功 |
| 400 | 请求参数错误 |
| 401 | 未授权/Token失效 |
| 403 | 权限不足 |
| 500 | 服务器内部错误 |

### 3.2 业务返回码 (code)
| code | 含义 | 处理方式 |
|------|------|----------|
| 0 | 成功 | 正常处理 |
| 401 | Token无效/未登录 | 重新登录 |
| 403 | 权限错误/设备掉线 | 检查状态 |
| 1001 | 业务错误(已处理过) | 忽略 |

### 3.3 错误码 (errno)
| errno | 含义 |
|-------|------|
| 50 | 设备掉线 |

---

## 四、本地TCP协议 (端口14745)

### 4.1 API调用格式

**通用格式**:
```
API名称|参数1|参数2|...|参数N
```

**返回格式**:
```
API名称|参数1|...|返回结果:Base64编码数据
```

### 4.2 完整API列表

#### 4.2.1 取绑定群
```
请求: 取绑定群|{机器人号}
返回: 取绑定群|{机器人号}|返回结果:{Base64}
```

#### 4.2.2 获取在线账号
```
请求: 云信_获取在线账号
返回: 云信_获取在线账号|返回结果:{Base64}
```

#### 4.2.3 发送群消息
```
请求: 发送群消息（文本）|{机器人号}|{内容}|{群号}|{类型}|{标志}
返回: 发送群消息（文本）|{机器人号}|{内容}|{群号}|{类型}|{标志}|返回结果:{Base64}

类型: 1=普通消息, 2=其他
标志: 0=正常发送
```

#### 4.2.4 发送私聊消息
```
请求: 发送好友消息|{机器人号}|{内容}|{目标号}
返回: 发送好友消息|{机器人号}|{内容}|{目标号}|返回结果:{Base64}
```

#### 4.2.5 群禁言控制
```
请求: ww_群禁言解禁|{机器人号}|{群号}|{动作}
返回: ww_群禁言解禁|{机器人号}|{群号}|{动作}|返回结果:{Base64}

动作: 1=禁言, 2=解禁
```

#### 4.2.6 修改群名片
```
请求: ww_改群名片|{机器人号}|{群号}|{用户号}|{新名片}
返回: ww_改群名片|{机器人号}|{群号}|{用户号}|{新名片}|返回结果:{Base64}
```

#### 4.2.7 获取群资料
```
请求: ww_获取群资料|{机器人号}|{群号}
返回: ww_获取群资料|{机器人号}|{群号}|返回结果:{Base64}
```

#### 4.2.8 ID互查
```
请求: ww_ID互查|{机器人号}|{旺商聊号}
返回: ww_ID互查|{机器人号}|{旺商聊号}|返回结果:{Base64}
```

#### 4.2.9 授权验证
```
请求: ww_xp限制接口|{状态}|{软件ID}|{授权码}|{用户名}|{时间1}|{时间2}
返回: ww_xp限制接口|{状态}|{软件ID}|{授权码}|{用户名}|{时间1}|{时间2}|返回结果:{Base64}

状态: 真/假
```

---

## 五、返回值解码

### 5.1 Base64解码方法

返回的Base64数据是**加密的二进制数据**，直接解码不可读：

```python
import base64

def decode_api_return(b64_str):
    """解码API返回值 - 返回原始字节"""
    try:
        return base64.b64decode(b64_str)
    except:
        return None
```

### 5.2 成功/失败判断

**方法1: 通过返回长度判断**
```python
def is_success(b64_result):
    """
    短返回通常表示简单成功
    长返回包含详细数据
    """
    decoded = base64.b64decode(b64_result)
    # 16字节以下通常是简单响应
    return len(decoded) <= 16
```

**方法2: 通过固定返回值对比**
```python
# 已知成功返回值
SUCCESS_RETURNS = {
    "TlllEPH6nt6j+I+wy69fZw==",  # 取绑定群成功
    "4PtLK0IVuLMRkWlrzZJH3w==",  # 发送消息成功
}

def is_known_success(b64_result):
    return b64_result in SUCCESS_RETURNS
```

### 5.3 已知返回值对照表

| Base64返回值 | 长度 | 含义 |
|-------------|------|------|
| `TlllEPH6nt6j+I+wy69fZw==` | 16字节 | 取绑定群成功(空) |
| `4PtLK0IVuLMRkWlrzZJH3w==` | 16字节 | 发送消息成功 |
| `iIEcyahRpLaUj9x+zriHjv0yoGMMK77efcp2lIzf0/Q=` | 32字节 | 授权验证成功 |
| 长Base64(>100字符) | 变长 | 包含数据的响应 |

---

## 六、NIM消息协议

### 6.1 消息JSON结构

```json
{
  "content": {
    "client_msg_id": "UUID消息ID",
    "server_msg_id": 2739491805904148336,
    "from_id": "1948408648",
    "from_nick": "发送者昵称(MD5)",
    "from_client_type": 16,
    "to_accid": "40821608989",
    "to_type": 1,
    "talk_id": "40821608989",
    "msg_type": 100,
    "msg_attach": "{\"b\":\"Base64Protobuf数据\"}",
    "msg_body": "",
    "msg_sub_type": 0,
    "time": 1768124458423,
    "offline_msg": 1,
    "push_enable": 1,
    "roam_msg": 1
  },
  "feature": 0,
  "rescode": 200
}
```

### 6.2 关键字段解析

| 字段 | 类型 | 说明 |
|------|------|------|
| `rescode` | int | NIM返回码，200=成功 |
| `to_type` | int | 0=私聊, 1=群聊 |
| `msg_type` | int | 0=文本, 100=自定义, 5=通知 |
| `msg_sub_type` | string | 消息子类型 |
| `from_client_type` | int | 16=PC, 2=iOS, 32=系统 |

### 6.3 消息子类型 (msg_sub_type)

| 值 | 含义 |
|----|------|
| `0` | 普通消息 |
| `NOTIFY_TYPE_GROUP_MUTE_1` | 群禁言开启 |
| `NOTIFY_TYPE_GROUP_MUTE_0` | 群禁言解除 |
| `NOTIFY_TYPE_USER_UPDATE_NAME` | 用户改名片 |

### 6.4 消息内容解码

消息内容在 `msg_attach.b` 字段中，是 **URL安全Base64编码的Protobuf数据**：

```python
import base64
import re

def decode_message_content(msg_attach):
    """
    解码消息内容
    输入: {"b":"URL安全Base64"}
    输出: (原始字节, 提取的文本)
    """
    import json
    
    attach = json.loads(msg_attach)
    b_content = attach.get('b', '')
    
    # URL安全Base64转标准Base64
    standard = b_content.replace('-', '+').replace('_', '/')
    padding = 4 - (len(standard) % 4)
    if padding < 4:
        standard += '=' * padding
    
    decoded = base64.b64decode(standard)
    
    # Protobuf结构: 头部(约12字节) + 数据
    # 尝试提取可读文本
    if len(decoded) > 12:
        payload = decoded[12:]
        text = payload.decode('utf-8', errors='ignore')
        # 清理不可打印字符
        clean = re.sub(r'[^\x20-\x7e\u4e00-\u9fff]', '', text)
        return decoded, clean
    
    return decoded, ""
```

---

## 七、插件投递格式

### 7.1 消息投递格式

当收到消息时，xplugin框架会以以下格式投递到ZCG：

```
机器人账号={robot_id}，主动账号={from_id}，被动账号={to_id}，群号={group_id}，内容={content}，消息ID={msg_id}，消息类型={msg_type}，消息时间={timestamp}，消息子类型={sub_type}，原始消息={raw_json}
```

### 7.2 字段对照表

| 插件字段 | NIM字段 | 说明 |
|---------|---------|------|
| 机器人账号 | - | 当前登录的机器人旺商聊号 |
| 主动账号 | from_id → 旺商聊号 | 发送者(需ID转换) |
| 被动账号 | to_accid → 旺商聊号 | 接收者(需ID转换) |
| 群号 | talk_id → 旺商聊群号 | 群号(需ID转换) |
| 内容 | msg_attach.b 解码 | 消息文本 |
| 消息类型 | msg_type映射 | 1001=私聊, 1002=群聊 |
| 消息时间 | time | 毫秒时间戳 |
| 消息子类型 | msg_sub_type | 事件子类型 |

### 7.3 消息类型映射

| 插件类型 | NIM to_type | 含义 |
|---------|-------------|------|
| 1001 | 0 | 私聊消息 |
| 1002 | 1 | 群聊消息 |
| 1003 | - | 系统通知 |
| 1015 | - | 好友申请 |

---

## 八、ID映射系统

### 8.1 双ID体系

旺商聊使用双ID体系：
- **旺商聊号**: 用户可见的账号(如 621705120)
- **NIM accid**: 网易云信内部ID(如 1948408648)

### 8.2 已知映射

| 旺商聊号 | NIM accid | 类型 |
|---------|-----------|------|
| 621705120 | 1948408648 | 机器人用户 |
| 781361487 | 1628907626 | 用户 |
| 324085447 | 1719936235 | 用户 |
| 3962369093 | 40821608989 | 群组 |

### 8.3 ID转换接口

使用 `ww_ID互查` API进行转换：
```
ww_ID互查|{机器人号}|{旺商聊号}
```

---

## 九、完整连接流程

### 9.1 初始化流程

```
1. 启动xplugin.exe (带授权参数)
   └─ xplugin.exe {Base64授权Token}

2. 加载插件 (Module.dll, zcg.dll等)

3. 授权验证
   └─ POST /v1/plugins/activation-code
   └─ 返回 code=0 表示成功

4. NIM SDK初始化
   └─ AppKey: 8a52a7cb1cff87c1e6ba5bfedc4c2e63
   └─ 连接云信服务器

5. 登录账号
   └─ accid: 1948408648 (对应621705120)

6. 启动心跳
   └─ 每60秒 GET /ping
   └─ 返回 code=0 表示在线

7. TCP服务就绪
   └─ 监听 127.0.0.1:14745
```

### 9.2 消息收发流程

**接收消息**:
```
1. NIM SDK收到消息
2. 解析JSON和Protobuf
3. ID转换 (NIM → 旺商聊)
4. 格式化为插件格式
5. 通过TCP发送到ZCG
```

**发送消息**:
```
1. ZCG通过TCP发送API调用
2. xplugin解析参数
3. ID转换 (旺商聊 → NIM)
4. 构造Protobuf
5. 通过NIM SDK发送
6. 返回Base64结果
```

---

## 十、Python实现示例

### 10.1 TCP客户端连接

```python
import socket
import threading
import time

class WangshangliaoClient:
    def __init__(self, host='127.0.0.1', port=14745):
        self.host = host
        self.port = port
        self.sock = None
        self.connected = False
        self.recv_buffer = b''
        
    def connect(self):
        """建立TCP连接"""
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((self.host, self.port))
            self.connected = True
            print(f"已连接到 {self.host}:{self.port}")
            return True
        except Exception as e:
            print(f"连接失败: {e}")
            return False
    
    def send_api(self, api_call):
        """发送API调用"""
        if not self.connected:
            return None
        try:
            # 添加换行符作为消息分隔
            data = (api_call + '\n').encode('utf-8')
            self.sock.send(data)
            return self.recv_response()
        except Exception as e:
            print(f"发送失败: {e}")
            return None
    
    def recv_response(self, timeout=5):
        """接收响应"""
        self.sock.settimeout(timeout)
        try:
            data = self.sock.recv(4096)
            return data.decode('utf-8', errors='ignore')
        except socket.timeout:
            return None
    
    def get_online_accounts(self):
        """获取在线账号"""
        return self.send_api("云信_获取在线账号")
    
    def get_bind_groups(self, robot_id):
        """获取绑定群"""
        return self.send_api(f"取绑定群|{robot_id}")
    
    def send_group_message(self, robot_id, content, group_id):
        """发送群消息"""
        content = content.replace('\n', '\\n')
        return self.send_api(f"发送群消息（文本）|{robot_id}|{content}|{group_id}|1|0")
    
    def send_private_message(self, robot_id, content, target_id):
        """发送私聊消息"""
        content = content.replace('\n', '\\n')
        return self.send_api(f"发送好友消息|{robot_id}|{content}|{target_id}")
    
    def group_mute(self, robot_id, group_id, mute=True):
        """群禁言"""
        action = "1" if mute else "2"
        return self.send_api(f"ww_群禁言解禁|{robot_id}|{group_id}|{action}")
    
    def close(self):
        """关闭连接"""
        if self.sock:
            self.sock.close()
            self.connected = False
```

### 10.2 返回值解析

```python
import base64
import re

class ResponseParser:
    # 已知成功返回值
    KNOWN_SUCCESS = {
        "TlllEPH6nt6j+I+wy69fZw==",
        "4PtLK0IVuLMRkWlrzZJH3w==",
    }
    
    @classmethod
    def parse_response(cls, response):
        """
        解析API响应
        返回: (成功?, API名称, 参数列表, Base64结果)
        """
        if not response:
            return False, None, [], None
        
        # 提取返回结果
        match = re.search(r'返回结果:(.+?)(?:\n|$)', response)
        if match:
            b64_result = match.group(1).strip()
            parts = response.split('|')
            api_name = parts[0] if parts else None
            params = parts[1:-1] if len(parts) > 2 else []
            
            success = cls.is_success(b64_result)
            return success, api_name, params, b64_result
        
        return False, None, [], None
    
    @classmethod
    def is_success(cls, b64_result):
        """判断是否成功"""
        if b64_result in cls.KNOWN_SUCCESS:
            return True
        try:
            decoded = base64.b64decode(b64_result)
            # 短响应通常是成功
            return len(decoded) <= 32
        except:
            return False
    
    @classmethod
    def decode_result(cls, b64_result):
        """解码返回值"""
        try:
            return base64.b64decode(b64_result)
        except:
            return None
```

### 10.3 消息内容解码

```python
import json
import base64
import re

class MessageDecoder:
    @staticmethod
    def decode_msg_attach(msg_attach_str):
        """
        解码消息附件
        输入: '{"b":"URL安全Base64"}'
        输出: (原始字节, 文本内容)
        """
        try:
            attach = json.loads(msg_attach_str)
            b_content = attach.get('b', '')
            
            # URL安全Base64转标准Base64
            standard = b_content.replace('-', '+').replace('_', '/')
            padding = 4 - (len(standard) % 4)
            if padding < 4:
                standard += '=' * padding
            
            decoded = base64.b64decode(standard)
            
            # 提取可读文本 (跳过Protobuf头部)
            text = ""
            if len(decoded) > 12:
                payload = decoded[12:]
                raw_text = payload.decode('utf-8', errors='ignore')
                # 提取中英文和数字
                text = re.sub(r'[^\x20-\x7e\u4e00-\u9fff\n]', '', raw_text)
            
            return decoded, text.strip()
            
        except Exception as e:
            return None, f"解码错误: {e}"
    
    @staticmethod
    def parse_plugin_message(text):
        """
        解析插件投递的消息
        """
        pattern = re.compile(
            r'机器人账号=([^，]*)，'
            r'主动账号=([^，]*)，'
            r'被动账号=([^，]*)，'
            r'群号=([^，]*)，'
            r'内容=([^，]*)，'
            r'消息ID=([^，]+)，'
            r'消息类型=([^，]+)，'
            r'消息时间=([^，]+)，'
            r'消息子类型=([^，]+)，'
            r'原始消息=(.*)',
            re.DOTALL
        )
        
        match = pattern.search(text)
        if match:
            return {
                'robot_id': match.group(1),
                'from_id': match.group(2),
                'to_id': match.group(3),
                'group_id': match.group(4),
                'content': match.group(5),
                'msg_id': match.group(6),
                'msg_type': match.group(7),
                'msg_time': match.group(8),
                'msg_sub_type': match.group(9),
                'raw_json': match.group(10)
            }
        return None
```

---

## 十一、错误处理

### 11.1 连接错误

| 错误 | 原因 | 解决方案 |
|------|------|----------|
| 连接拒绝 | xplugin未启动 | 先启动xplugin.exe |
| 连接超时 | 端口被占用 | 检查14745端口 |
| 连接中断 | 程序崩溃 | 重启程序 |

### 11.2 API错误

| 返回码 | 原因 | 解决方案 |
|--------|------|----------|
| code=401 | Token失效 | 重新登录 |
| code=403 | 设备掉线 | 检查网络 |
| code=1001 | 重复操作 | 忽略 |
| errno=50 | 账号掉线 | 重连 |

---

## 十二、附录

### 12.1 常用端点汇总

| 端点 | 方法 | 用途 |
|------|------|------|
| `/v1/plugins/activation-code` | POST | 授权验证 |
| `/v1/group/set-group-mute` | POST | 群禁言 |
| `/v1/plugins/handle-relation-ask-friend` | POST | 好友申请 |
| `/v1/plugins/get-gid` | POST | ID查询 |
| `/ping` | GET | 心跳检测 |

### 12.2 NIM AppKey

```
AppKey: 8a52a7cb1cff87c1e6ba5bfedc4c2e63
```

### 12.3 消息类型对照

| msg_type | 名称 | 说明 |
|----------|------|------|
| 0 | TEXT | 文本消息 |
| 1 | IMAGE | 图片消息 |
| 2 | VOICE | 语音消息 |
| 5 | NOTIFICATION | 通知消息 |
| 100 | CUSTOM | 自定义消息 |

---

## 十三、禁言/解禁协议深度解析

### 13.1 禁言API完整流程

```
┌──────────┐    TCP调用     ┌──────────┐    HTTP POST    ┌──────────┐
│  ZCG机器人 │ ──────────► │  xplugin  │ ─────────────► │ 旺商聊服务器│
│           │              │           │                │           │
│ ww_群禁言解禁│             │ /v1/group/│                │  处理请求  │
│ |机器人|群|1│             │ set-group-│                │           │
└──────────┘              │ mute      │                └──────────┘
      ▲                    └──────────┘                      │
      │                         │                            │
      │    Base64返回结果        │      JSON响应              │
      └─────────────────────────┴────────────────────────────┘
```

### 13.2 本地TCP禁言命令

**禁言命令格式**:
```
ww_群禁言解禁|{机器人号}|{群号}|{动作}
```

**参数说明**:
| 参数 | 类型 | 说明 |
|------|------|------|
| 机器人号 | string | 旺商聊机器人账号，如 `621705120` |
| 群号 | string | 旺商聊群号，如 `3962369093` |
| 动作 | int | `1`=禁言, `2`=解禁 |

**实际调用示例**:
```
# 禁言
ww_群禁言解禁|621705120|3962369093|1

# 解禁
ww_群禁言解禁|621705120|3962369093|2
```

**返回格式**:
```
ww_群禁言解禁|621705120|3962369093|1|返回结果:iIEcyahRpLaUj9x+zriHjm1S4/uHjzwXxIvTKtsxAjWRDmEkKr+/mNOeaxfIZl28
```

### 13.3 HTTP API详细协议

**接口**: `POST /v1/group/set-group-mute`

**请求头**:
```http
Content-Type: application/json
x-token: {认证Token}
X-Device: 1
x-id: {用户ID}
x-group-token: {群组Token}
```

**请求体 - 禁言**:
```json
{
  "groupId": 1176721,
  "muteMode": "MUTE_MEMBER"
}
```

**请求体 - 全员禁言**:
```json
{
  "groupId": 1176721,
  "muteMode": "MUTE_ALL"
}
```

**请求体 - 解禁**:
```json
{
  "groupId": 1176721,
  "muteMode": "MUTE_NO"
}
```

**muteMode 完整取值**:
| 值 | 含义 | 说明 |
|----|------|------|
| `MUTE_ALL` | 全员禁言 | 除管理员外全部禁言 |
| `MUTE_MEMBER` | 成员禁言 | 指定成员禁言 |
| `MUTE_NO` | 解除禁言 | 解除全员禁言 |

### 13.4 返回值解析

**成功响应**:
```json
{
  "code": 0,
  "msg": "OK",
  "data": {}
}
```

**失败响应 - Token无效**:
```json
{
  "code": 401,
  "msg": "无效的token或未登录",
  "line": 933,
  "file": "appx_context"
}
```

**Base64返回值对照**:
| 场景 | Base64返回值 | 解码含义 |
|------|-------------|----------|
| 禁言成功 | `iIEcyahRpLaUj9x+zriHjm1S4/uHjzwXxIvTKtsxAjWRDmEkKr+/mNOeaxfIZl28` | 加密的成功标识 |
| 无Token失败 | `8H6fOpMKYldD2IzCr5hZlzRM0jehME4V4C5akb0PKks3Q3jlcMQ9PLJrTThFlP77CFh7EDDdqGUQYhgG7suJTumSbRWtJzwMEktqaq5ugsu4iEUULSWLtMvqc5jbLxid5AKHxjbDoNJmZAl+wLJ94Q==` | Token校验失败 |

### 13.5 禁言通知消息

当群禁言状态改变时，NIM会推送通知消息：

**禁言开启通知**:
```
消息子类型: NOTIFY_TYPE_GROUP_MUTE_1
消息类型: 1002 (群消息)
msg_type: 5 (通知消息)
```

**禁言解除通知**:
```
消息子类型: NOTIFY_TYPE_GROUP_MUTE_0
消息类型: 1002 (群消息)
msg_type: 5 (通知消息)
```

### 13.6 NIM通知消息结构

**完整的禁言通知JSON**:
```json
{
  "content": {
    "client_msg_id": "ab729665-6b06-4f7d-a814-a59d3595b1fa",
    "from_client_type": 32,
    "from_id": "1948408648",
    "from_nick": "a4ece45c6b12086f4e82bac509caec3d",
    "log_status": 2,
    "msg_type": 5,
    "msg_attach": "{...team_info...}",
    "talk_id": "40821608989",
    "to_accid": "40821608989",
    "to_type": 1,
    "time": 1768112829571
  },
  "rescode": 200
}
```

**msg_attach中的team_info结构**:
```json
{
  "data": {
    "name_cards": [
      {
        "accid": "1948408648",
        "name": "d153f4e86e8c0eda3867e842e507cd93",
        "icon": "791610986162052788",
        "ex": "{\"nickname_ciphertext\":\"mtmQz6FQ9lG6P3ZaOPXWrg==\"}"
      }
    ],
    "team_info": {
      "mute_all": 1,
      "mute_type": 1,
      "tid": "40821608989",
      "update_timetag": 1768112829565
    }
  },
  "id": 3
}
```

**team_info字段解析**:
| 字段 | 禁言状态值 | 解禁状态值 | 说明 |
|------|-----------|-----------|------|
| `mute_all` | 1 | 0 | 是否全员禁言 |
| `mute_type` | 1 | 0 | 禁言类型 |
| `tid` | 群NIM ID | 群NIM ID | 群组标识 |
| `update_timetag` | 时间戳 | 时间戳 | 更新时间(毫秒) |

### 13.7 判断禁言成功的方法

**方法1: 检查返回值长度**
```python
def is_mute_success(b64_result):
    """
    禁言成功的返回值通常是固定长度
    """
    import base64
    try:
        decoded = base64.b64decode(b64_result)
        # 成功返回通常是48-64字节
        return 40 <= len(decoded) <= 70
    except:
        return False
```

**方法2: 监听禁言通知**
```python
def on_message(msg):
    """
    通过监听禁言通知确认状态
    """
    if msg.get('msg_sub_type') == 'NOTIFY_TYPE_GROUP_MUTE_1':
        # 禁言成功
        team_info = parse_team_info(msg['msg_attach'])
        if team_info['mute_all'] == 1:
            return True, "禁言成功"
    
    elif msg.get('msg_sub_type') == 'NOTIFY_TYPE_GROUP_MUTE_0':
        # 解禁成功
        team_info = parse_team_info(msg['msg_attach'])
        if team_info['mute_all'] == 0:
            return True, "解禁成功"
    
    return False, "状态未知"
```

### 13.8 完整Python实现

```python
import socket
import base64
import json
import re

class MuteController:
    """禁言控制器"""
    
    def __init__(self, host='127.0.0.1', port=14745):
        self.host = host
        self.port = port
        self.sock = None
        
    def connect(self):
        """连接到xplugin"""
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((self.host, self.port))
        self.sock.settimeout(10)
        return True
    
    def mute_group(self, robot_id: str, group_id: str) -> tuple:
        """
        禁言群组
        返回: (成功?, Base64结果, 错误信息)
        """
        cmd = f"ww_群禁言解禁|{robot_id}|{group_id}|1\n"
        return self._send_and_parse(cmd)
    
    def unmute_group(self, robot_id: str, group_id: str) -> tuple:
        """
        解禁群组
        返回: (成功?, Base64结果, 错误信息)
        """
        cmd = f"ww_群禁言解禁|{robot_id}|{group_id}|2\n"
        return self._send_and_parse(cmd)
    
    def _send_and_parse(self, cmd: str) -> tuple:
        """发送命令并解析响应"""
        try:
            self.sock.send(cmd.encode('utf-8'))
            response = self.sock.recv(4096).decode('utf-8', errors='ignore')
            
            # 提取Base64返回值
            match = re.search(r'返回结果:(.+?)(?:\n|$)', response)
            if match:
                b64_result = match.group(1).strip()
                success = self._check_success(b64_result)
                return success, b64_result, None
            
            return False, None, "无返回结果"
            
        except Exception as e:
            return False, None, str(e)
    
    def _check_success(self, b64_result: str) -> bool:
        """检查是否成功"""
        try:
            decoded = base64.b64decode(b64_result)
            # 成功返回通常是48-64字节的加密数据
            return 40 <= len(decoded) <= 70
        except:
            return False
    
    def close(self):
        """关闭连接"""
        if self.sock:
            self.sock.close()


class MuteNotificationParser:
    """禁言通知解析器"""
    
    @staticmethod
    def parse(msg_text: str) -> dict:
        """
        解析禁言/解禁通知
        返回: {
            'event': 'mute'/'unmute',
            'group_id': 群号,
            'operator': 操作者,
            'timestamp': 时间戳
        }
        """
        result = {
            'event': None,
            'group_id': None,
            'operator': None,
            'timestamp': None
        }
        
        # 检测禁言事件
        if 'NOTIFY_TYPE_GROUP_MUTE_1' in msg_text:
            result['event'] = 'mute'
        elif 'NOTIFY_TYPE_GROUP_MUTE_0' in msg_text:
            result['event'] = 'unmute'
        else:
            return result
        
        # 提取群号
        group_match = re.search(r'群号=(\d+)', msg_text)
        if group_match:
            result['group_id'] = group_match.group(1)
        
        # 提取team_info
        try:
            # 找到msg_attach中的JSON
            attach_match = re.search(r'"msg_attach":\s*"([^"]+)"', msg_text)
            if attach_match:
                attach_str = attach_match.group(1)
                # 反转义
                attach_str = attach_str.replace('\\n', '\n').replace('\\t', '\t').replace('\\"', '"')
                attach = json.loads(attach_str)
                
                team_info = attach.get('data', {}).get('team_info', {})
                result['mute_all'] = team_info.get('mute_all')
                result['mute_type'] = team_info.get('mute_type')
                result['timestamp'] = team_info.get('update_timetag')
                
        except Exception as e:
            pass
        
        return result


# 使用示例
if __name__ == '__main__':
    # 禁言示例
    controller = MuteController()
    if controller.connect():
        # 禁言
        success, result, error = controller.mute_group('621705120', '3962369093')
        print(f"禁言: 成功={success}, 结果={result}")
        
        # 解禁
        success, result, error = controller.unmute_group('621705120', '3962369093')
        print(f"解禁: 成功={success}, 结果={result}")
        
        controller.close()
```

### 13.9 ID转换说明

**禁言时需要的ID**:
- 本地TCP调用使用**旺商聊号**
- HTTP API使用**旺商聊groupId**(数字ID)
- NIM通知中的tid是**NIM群组ID**

**ID映射示例**:
| 旺商聊群号 | 旺商聊groupId | NIM tid |
|-----------|--------------|---------|
| 3962369093 | 1176721 | 40821608989 |

### 13.10 错误处理

| 错误码 | 含义 | 解决方案 |
|--------|------|----------|
| 401 | Token无效/未登录 | 重新登录获取token |
| 403 | 无权限 | 检查是否为群管理员 |
| 404 | 群不存在 | 检查群号是否正确 |
| 500 | 服务器错误 | 稍后重试 |

---

## 十四、ID用户账户查询协议深度解析

### 14.1 ID体系说明

旺商聊使用**三种ID体系**：
| ID类型 | 格式 | 示例 | 说明 |
|--------|------|------|------|
| 旺商聊号 | 6-10位数字 | `621705120` | 用户可见账号 |
| NIM accid | 10位数字 | `1948408648` | 云信内部ID |
| 旺商聊uid | 7-8位数字 | `9502248` | 平台内部用户ID |

### 14.2 本地TCP ID互查命令

**命令格式**:
```
ww_ID互查|{机器人号}|{查询ID}
```

**实际调用示例**:
```
# 查询用户 324085447
ww_ID互查|621705120|324085447

# 查询用户 184800772
ww_ID互查|621705120|184800772
```

**成功返回**:
```
ww_ID互查|621705120|324085447|返回结果:iIEcyahRpLaUj9x+zriHjvJYfN+c+jgiXgYkOxhtHts40GYpzm5t4YbWZdaoKcsHTSwIPGcjsr53VtRV/9BEh7zKAuqmpTA5sS3DIivtRsq3k+riGzc/DvaJN6N9oKWDn64boYAffz4+1G5m4+zCxiFTKAGtTd2A52pLStB2QlA=
```

### 14.3 HTTP API协议

#### 14.3.1 获取用户信息接口

**接口**: `POST /v1/plugins/get-userinfo-by-id`

**请求头**:
```http
Content-Type: application/json
x-token: {认证Token}
X-Device: 1
x-id: {当前用户ID}
x-group-token: {群组Token}
```

**请求体**:
```json
{
  "nimId": 1889399900,
  "group_id": "1176721"
}
```

或:
```json
{
  "id": 324085447,
  "type": 1
}
```

**type参数说明**:
| type值 | 含义 | 输入 | 输出 |
|--------|------|------|------|
| 0 | NIM ID → 旺商聊号 | NIM accid | 旺商聊号 |
| 1 | 旺商聊号 → NIM ID | 旺商聊号 | NIM accid |
| 2 | 群组ID查询 | 群号 | 群组信息 |

#### 14.3.2 获取群组ID接口

**接口**: `POST /v1/plugins/get-gid`

**请求体**:
```json
{
  "id": "3962369093",
  "type": 2
}
```

**成功响应**:
```json
{
  "code": 0,
  "msg": "OK",
  "data": {
    "groupAccount": "3962369093"
  }
}
```

### 14.4 返回值解析

#### 14.4.1 成功返回值

**Base64返回值** (成功查询):
```
iIEcyahRpLaUj9x+zriHjvJYfN+c+jgiXgYkOxhtHts40GYpzm5t4YbWZdaoKcsHTSwIPGcjsr53VtRV/9BEh7zKAuqmpTA5sS3DIivtRsq3k+riGzc/DvaJN6N9oKWDn64boYAffz4+1G5m4+zCxiFTKAGtTd2A52pLStB2QlA=
```

**特征**:
- Base64解码后长度: **100-150字节**
- 包含加密的用户信息数据

#### 14.4.2 失败返回值

**Token无效** (code=401):
```json
{
  "code": 401,
  "msg": "无效的token或未登录",
  "line": 933,
  "file": "appx_context"
}
```

**用户不存在** (code=1001):
```json
{
  "code": 1001,
  "msg": "用户不存在",
  "line": 55,
  "file": "api_core_Plugins_GetUserInfoById"
}
```

**没有用户ID** (code=-10243):
```json
{
  "id": "97927325141102",
  "code": -10243,
  "errno": 48,
  "msg": "no user id"
}
```

**消息发送错误** (code=-10261):
```json
{
  "id": "99112940334420",
  "code": -10261,
  "errno": -236,
  "msg": "message error -236"
}
```

### 14.5 返回码完整对照表

| code | 含义 | 处理方式 |
|------|------|----------|
| 0 | 成功 | 解析返回数据 |
| 401 | Token无效/未登录 | 重新获取Token |
| 1001 | 用户不存在/已处理 | 提示用户不存在 |
| -10243 | 没有用户ID | 检查输入参数 |
| -10261 | 消息错误 | 重试或忽略 |

### 14.6 已知ID映射表

从日志中提取的已知ID映射：

| 旺商聊号 | NIM accid | 旺商聊uid | 说明 |
|---------|-----------|-----------|------|
| 621705120 | 1948408648 | 9502248 | 机器人账号 |
| 781361487 | 1628907626 | 9903485 | 用户1 |
| 324085447 | 1719936235 | 7984877 | 用户2 |
| 184800772 | 1700699909 | - | 用户3 |
| 250416936 | - | - | 用户4 |
| 82840376 | 1391351554 | - | 用户5 |
| 982576571 | 2092166259 | - | 用户6 |

**群组映射**:
| 旺商聊群号 | NIM tid | groupId |
|-----------|---------|---------|
| 3962369093 | 40821608989 | 1176721 |

### 14.7 判断成功/失败的方法

```python
import base64
import json
import re

def parse_id_query_result(response: str) -> dict:
    """
    解析ID查询结果
    返回: {
        'success': bool,
        'data': 解码数据或None,
        'error_code': 错误码或None,
        'error_msg': 错误信息或None
    }
    """
    result = {
        'success': False,
        'data': None,
        'error_code': None,
        'error_msg': None
    }
    
    # 提取Base64返回值
    match = re.search(r'返回结果:(.+?)(?:\n|$)', response)
    if not match:
        return result
    
    b64_result = match.group(1).strip()
    
    try:
        decoded = base64.b64decode(b64_result)
        decoded_len = len(decoded)
        
        # 成功的返回值通常是100-150字节的加密数据
        if 90 <= decoded_len <= 200:
            result['success'] = True
            result['data'] = decoded
        else:
            # 可能是JSON错误信息
            try:
                text = decoded.decode('utf-8', errors='ignore')
                error = json.loads(text)
                result['error_code'] = error.get('code')
                result['error_msg'] = error.get('msg')
            except:
                pass
                
    except Exception as e:
        result['error_msg'] = str(e)
    
    return result


def is_id_query_success(b64_result: str) -> bool:
    """
    快速判断ID查询是否成功
    """
    try:
        decoded = base64.b64decode(b64_result)
        # 成功返回: 100-150字节
        # 失败返回: 通常<50字节或>200字节
        return 90 <= len(decoded) <= 200
    except:
        return False
```

### 14.8 完整Python实现

```python
import socket
import base64
import re

class IDQueryClient:
    """ID查询客户端"""
    
    def __init__(self, host='127.0.0.1', port=14745):
        self.host = host
        self.port = port
        self.sock = None
        
    def connect(self):
        """连接到xplugin"""
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((self.host, self.port))
        self.sock.settimeout(10)
        return True
    
    def query_id(self, robot_id: str, target_id: str) -> dict:
        """
        查询用户ID信息
        返回: {
            'success': bool,
            'wsl_id': 旺商聊号或None,
            'nim_id': NIM ID或None,
            'raw_b64': 原始Base64返回,
            'error': 错误信息或None
        }
        """
        cmd = f"ww_ID互查|{robot_id}|{target_id}\n"
        
        try:
            self.sock.send(cmd.encode('utf-8'))
            response = self.sock.recv(4096).decode('utf-8', errors='ignore')
            
            # 提取Base64返回值
            match = re.search(r'返回结果:(.+?)(?:\n|$)', response)
            if not match:
                return {
                    'success': False,
                    'error': '无返回结果'
                }
            
            b64_result = match.group(1).strip()
            decoded = base64.b64decode(b64_result)
            
            # 判断成功/失败
            if 90 <= len(decoded) <= 200:
                return {
                    'success': True,
                    'wsl_id': target_id,  # 查询的ID
                    'nim_id': None,       # 需要从加密数据中解析
                    'raw_b64': b64_result,
                    'error': None
                }
            else:
                return {
                    'success': False,
                    'raw_b64': b64_result,
                    'error': '查询失败或用户不存在'
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }
    
    def close(self):
        """关闭连接"""
        if self.sock:
            self.sock.close()


# 使用示例
if __name__ == '__main__':
    client = IDQueryClient()
    if client.connect():
        # 查询用户ID
        result = client.query_id('621705120', '324085447')
        print(f"查询结果: {result}")
        
        if result['success']:
            print(f"用户 {result['wsl_id']} 查询成功")
            print(f"Base64数据长度: {len(base64.b64decode(result['raw_b64']))} 字节")
        else:
            print(f"查询失败: {result['error']}")
        
        client.close()
```

### 14.9 批量ID查询

```python
def batch_query_ids(robot_id: str, id_list: list) -> dict:
    """
    批量查询ID
    返回: {id: result_dict}
    """
    results = {}
    client = IDQueryClient()
    
    if client.connect():
        for target_id in id_list:
            result = client.query_id(robot_id, target_id)
            results[target_id] = result
            # 添加延迟防止请求过快
            import time
            time.sleep(0.1)
        
        client.close()
    
    return results


# 使用示例
ids_to_query = ['324085447', '184800772', '250416936']
results = batch_query_ids('621705120', ids_to_query)

for id, result in results.items():
    status = "成功" if result['success'] else "失败"
    print(f"ID {id}: {status}")
```

### 14.10 错误处理建议

| 错误场景 | 处理方式 |
|---------|----------|
| code=401 | 重新登录获取Token后重试 |
| code=1001 | 用户不存在，记录并跳过 |
| code=-10243 | 参数错误，检查输入 |
| 超时无响应 | 重连后重试 |
| Base64解码失败 | 记录错误，跳过该查询 |

---

## 十五、群聊发送消息协议深度解析

### 15.1 发送群消息流程

```
┌──────────┐                    ┌──────────┐                    ┌──────────┐
│  ZCG机器人 │  ─TCP调用──────►  │  xplugin  │  ─HTTP API──────► │  旺商聊    │
│           │                    │           │                    │  服务器   │
│ 发送群消息 │                    │ encode-msg│                    │          │
│ （文本）   │                    │           │                    │  NIM SDK │
└──────────┘                    └──────────┘                    └──────────┘
      ▲                              │                              │
      │        Base64返回            │        rescode:200           │
      └──────────────────────────────┴──────────────────────────────┘
```

### 15.2 本地TCP命令格式

#### 15.2.1 发送群消息（文本）

**命令格式**:
```
发送群消息（文本）|{机器人号}|{消息内容}|{群号}|{类型}|{标志}
```

**参数说明**:
| 参数 | 类型 | 说明 | 示例 |
|------|------|------|------|
| 机器人号 | string | 旺商聊机器人账号 | `621705120` |
| 消息内容 | string | 发送的文本内容(换行用`\n`) | `开期:3+6+2=11` |
| 群号 | string | 旺商聊群号 | `3962369093` |
| 类型 | int | 消息类型 | `1`=普通消息 |
| 标志 | int | 发送标志 | `0`=正常发送 |

**实际调用示例**:
```
# 发送开期消息
发送群消息（文本）|621705120|开期:3+6+2=11 XD 期3382950期|3962369093|1|0

# 发送封盘消息
发送群消息（文本）|621705120|==已经封盘==\n请等待开奖\n==请勿下注==|3962369093|1|0

# 发送开奖结果
发送群消息（文本）|621705120|开_:3 + 6 + 2 = 11 XD -- B\n买:0  总盈:0\n----------------------|3962369093|1|0
```

**成功返回**:
```
发送群消息（文本）|621705120|...|3962369093|1|0|返回结果:Dg15wK9Ua6C+fcRgZoN3NQ==
```

#### 15.2.2 发送好友消息(私聊)

**命令格式**:
```
发送好友消息|{机器人号}|{消息内容}|{目标号}
```

**实际调用示例**:
```
# 发送私聊消息
发送好友消息|621705120|您好(7813)\n查壬期积分记录\n当前余:0|781361487
```

**成功返回**:
```
发送好友消息|621705120|...|781361487|返回结果:Dg15wK9Ua6C+fcRgZoN3NQ==
```

### 15.3 成功/失败返回值

**固定成功返回值**:
```
Dg15wK9Ua6C+fcRgZoN3NQ==
```
- Base64解码后: **16字节**
- 十六进制: `0E-0D-79-C0-AF-54-6B-A0-BE-7D-C4-60-66-83-77-35`

**判断成功方法**:
```python
def is_send_success(b64_result: str) -> bool:
    """判断发送消息是否成功"""
    return b64_result == "Dg15wK9Ua6C+fcRgZoN3NQ=="
```

### 15.4 消息编码API

**HTTP接口**: `POST /v1/plugins/encode-msg`

**请求头**:
```http
Content-Type: application/json
x-token: {认证Token}
X-Device: 1
x-id: {用户ID}
Referer: http://127.0.0.1:51234/v1/plugins/encode-msg
```

### 15.5 JSON消息结构(带@艾特功能)

**完整消息JSON**:
```json
{
  "msg": {
    "from": {
      "id": 9502248,
      "name": "用户昵称",
      "avatar": "0"
    },
    "to": {
      "id": 1176721
    },
    "msgDevice": "Desktop",
    "created_at": "2026-01-11T04:56:03Z",
    "msgSession": "MSG_KIND_GROUP",
    "msgVersion": 2,
    "accountType": "ACCOUNT_MEMBER",
    "msgFormat": "MSG_TEXT",
    "msgRole": "MSG_MINE",
    "msgRingtone": "MSG_RINGTONE_NONE",
    "appoint": "MSG_APPOINT_NONE",
    "aite": {
      "content": {
        "data": "@某用户  (9825)\n您的查询结果\n当前余:0",
        "title": "",
        "style": "MSG_STYLE_PLAIN",
        "color": ""
      },
      "AiTeInfo": [
        {
          "uid": 2092166259,
          "nick": "某用户",
          "start": "0",
          "end": "4"
        }
      ]
    }
  }
}
```

### 15.6 消息字段说明

| 字段 | 说明 | 取值 |
|------|------|------|
| `msgSession` | 消息会话类型 | `MSG_KIND_GROUP`=群聊, `MSG_KIND_P2P`=私聊 |
| `msgFormat` | 消息格式 | `MSG_TEXT`=文本 |
| `msgRole` | 消息角色 | `MSG_MINE`=自己发送, `MSG_MEMBER`=成员 |
| `accountType` | 账号类型 | `ACCOUNT_MEMBER`=成员, `ACCOUNT_SYSTEM`=系统 |
| `msgDevice` | 设备类型 | `Desktop`=桌面端, `Mobile`=移动端 |

### 15.7 @艾特功能协议

**AiTeInfo结构**:
```json
{
  "uid": 2092166259,      // 被@用户的NIM ID
  "nick": "用户昵称",      // 显示的昵称
  "start": "0",           // @符号在消息中的起始位置
  "end": "4"              // @昵称的结束位置
}
```

**@消息内容格式**:
```
@昵称  (短号)\n消息正文
```

示例:
```
@某用户  (9825)\n您的查壬期积分记录\n当前余:0
```

### 15.8 算账开期完整协议

**算账流程**:
```
1. 封盘通知
   发送群消息（文本）|621705120|==已经封盘==\n请等待开奖\n==请勿下注==|3962369093|1|0

2. 开奖倒计时
   发送群消息（文本）|621705120|开期\n-------------------\n|3962369093|1|0

3. 开奖结果
   发送群消息（文本）|621705120|开期:3+6+2=11 XD 期3382950期|3962369093|1|0

4. 算账明细
   发送群消息（文本）|621705120|开_:3 + 6 + 2 = 11 XD -- B\n买:0  总盈:0\n----------------------\nls:09 17 13...|3962369093|1|0

5. 解除封盘
   发送群消息（文本）|621705120|--当前距离封盘还有40秒--\n请开始下注 单注 元|3962369093|1|0
```

**开期消息格式**:
```
开期:{数字1}+{数字2}+{数字3}={总和} {大小单双} 期{期数}期
```

示例: `开期:3+6+2=11 XD 期3382950期`

**算账结果消息格式**:
```
开_:{数字1} + {数字2} + {数字3} = {总和} {大小单双} -- {波色}
买:{下注金额}  总盈:{盈亏}
----------------------
ls:{历史开奖}
大小ls:{历史大小}
β色ls:{历史波色}
当前期盈亏: -- -- -- -- -- -- -- -- -- 
```

### 15.9 改群名片协议

**命令格式**:
```
ww_改群名片|{机器人号}|{群号}|{用户号}|{新名片}
```

**实际调用**:
```
ww_改群名片|621705120|3962369093|781361487|新昵称
ww_改群名片|621705120|3962369093|82840376|用户A
```

**成功返回**:
```
ww_改群名片|621705120|3962369093|781361487|新昵称|返回结果:iIEcyahRpLaUj9x+zriHjrEofo2tJZMOukxTXDb1u7slBJk8lkDxPu3N0kxB7wyHB4oFjIxygwFGWyHzjAdh2/Fathlg5Ek8DoHJg5by/cjCTVB2OV3OWceW1m4KcPuB
```

### 15.10 完整Python实现

```python
import socket
import time
import re

class GroupMessageSender:
    """群消息发送器"""
    
    # 成功返回值
    SUCCESS_RETURN = "Dg15wK9Ua6C+fcRgZoN3NQ=="
    
    def __init__(self, host='127.0.0.1', port=14745):
        self.host = host
        self.port = port
        self.sock = None
        
    def connect(self):
        """连接到xplugin"""
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((self.host, self.port))
        self.sock.settimeout(10)
        return True
    
    def send_group_message(self, robot_id: str, content: str, group_id: str) -> dict:
        """
        发送群消息
        返回: {'success': bool, 'raw_result': str, 'error': str}
        """
        # 转义换行符
        content = content.replace('\n', '\\n')
        
        cmd = f"发送群消息（文本）|{robot_id}|{content}|{group_id}|1|0\n"
        return self._send_and_check(cmd)
    
    def send_private_message(self, robot_id: str, content: str, target_id: str) -> dict:
        """
        发送私聊消息
        """
        content = content.replace('\n', '\\n')
        cmd = f"发送好友消息|{robot_id}|{content}|{target_id}\n"
        return self._send_and_check(cmd)
    
    def send_lottery_result(self, robot_id: str, group_id: str, 
                           num1: int, num2: int, num3: int, 
                           period: int) -> dict:
        """
        发送开奖结果
        """
        total = num1 + num2 + num3
        
        # 判断大小单双
        size = "大" if total >= 11 else "小"
        parity = "单" if total % 2 == 1 else "双"
        
        # 构建消息
        content = f"开期:{num1}+{num2}+{num3}={total} {size}{parity} 期{period}期"
        
        return self.send_group_message(robot_id, content, group_id)
    
    def send_seal_notice(self, robot_id: str, group_id: str) -> dict:
        """发送封盘通知"""
        content = "==已经封盘==\\n请等待开奖\\n==请勿下注=="
        return self.send_group_message(robot_id, content, group_id)
    
    def send_open_notice(self, robot_id: str, group_id: str, seconds: int = 40) -> dict:
        """发送开盘通知"""
        content = f"--当前距离封盘还有{seconds}秒--\\n请开始下注 单注 元"
        return self.send_group_message(robot_id, content, group_id)
    
    def change_group_card(self, robot_id: str, group_id: str, 
                         user_id: str, new_card: str) -> dict:
        """修改群名片"""
        cmd = f"ww_改群名片|{robot_id}|{group_id}|{user_id}|{new_card}\n"
        return self._send_and_check(cmd, check_short=False)
    
    def _send_and_check(self, cmd: str, check_short: bool = True) -> dict:
        """发送命令并检查结果"""
        try:
            self.sock.send(cmd.encode('utf-8'))
            response = self.sock.recv(4096).decode('utf-8', errors='ignore')
            
            # 提取返回值
            match = re.search(r'返回结果:(.+?)(?:\n|$)', response)
            if match:
                b64_result = match.group(1).strip()
                
                if check_short:
                    success = b64_result == self.SUCCESS_RETURN
                else:
                    # 改群名片等API返回较长的Base64
                    success = len(b64_result) > 20
                
                return {
                    'success': success,
                    'raw_result': b64_result,
                    'error': None
                }
            
            return {
                'success': False,
                'raw_result': None,
                'error': '无返回结果'
            }
            
        except Exception as e:
            return {
                'success': False,
                'raw_result': None,
                'error': str(e)
            }
    
    def close(self):
        """关闭连接"""
        if self.sock:
            self.sock.close()


# 使用示例 - 算账流程
def run_lottery_round(robot_id: str, group_id: str, period: int):
    """执行一轮算账"""
    sender = GroupMessageSender()
    
    if not sender.connect():
        print("连接失败")
        return
    
    try:
        # 1. 发送封盘通知
        result = sender.send_seal_notice(robot_id, group_id)
        print(f"封盘通知: {'成功' if result['success'] else '失败'}")
        time.sleep(2)
        
        # 2. 模拟开奖 (这里用随机数，实际从开奖源获取)
        import random
        num1, num2, num3 = random.randint(0, 9), random.randint(0, 9), random.randint(0, 9)
        
        # 3. 发送开奖结果
        result = sender.send_lottery_result(robot_id, group_id, num1, num2, num3, period)
        print(f"开奖结果: {'成功' if result['success'] else '失败'}")
        print(f"  开奖号码: {num1}+{num2}+{num3}={num1+num2+num3}")
        time.sleep(3)
        
        # 4. 发送开盘通知
        result = sender.send_open_notice(robot_id, group_id)
        print(f"开盘通知: {'成功' if result['success'] else '失败'}")
        
    finally:
        sender.close()


# 执行
if __name__ == '__main__':
    run_lottery_round('621705120', '3962369093', 3382951)
```

### 15.11 NIM发送确认

**NIM SDK成功响应**:
```json
{
  "content": {
    "client_msg_id": "05768f688da3dfb194c9a2e43d1b5cd4",
    "from_id": "1948408648",
    "to_accid": "40821608989",
    "to_type": 1,
    "msg_type": 100,
    "server_msg_id": 2739491805904148286,
    "time": 1768111375322
  },
  "rescode": 200
}
```

**关键字段**:
- `rescode: 200` = NIM发送成功
- `to_type: 1` = 群聊
- `server_msg_id` = 服务器分配的消息ID

---

## 十六、最底层通信协议深度解析

### 16.1 协议架构总览

```
┌─────────────────────────────────────────────────────────────────────┐
│                          应用层 (ZCG机器人)                           │
├─────────────────────────────────────────────────────────────────────┤
│                      本地TCP API (端口14745)                          │
│              发送群消息（文本）|621705120|...|3962369093|1|0           │
├─────────────────────────────────────────────────────────────────────┤
│                      xplugin 框架层                                   │
│                    (协议转换/认证管理)                                 │
├─────────────────────────────────────────────────────────────────────┤
│                    HTTP API层 (端口51234)                            │
│          POST /v1/plugins/encode-msg + 认证头                        │
├─────────────────────────────────────────────────────────────────────┤
│                    NIM SDK层 (云信IM)                                │
│              Protobuf编码 + AES加密                                  │
├─────────────────────────────────────────────────────────────────────┤
│                    TCP/TLS 传输层                                    │
│              连接云信服务器 lbs.netease.im                            │
└─────────────────────────────────────────────────────────────────────┘
```

### 16.2 本地TCP协议 (最底层接口)

**端口**: `127.0.0.1:14745`

**连接参数**:
```
协议: TCP
编码: UTF-8
分隔符: \n (换行符)
超时: 建议10秒
```

**消息格式**:
```
发送: API命令|参数1|参数2|...|参数N\n
接收: API命令|参数1|...|返回结果:Base64Data
```

### 16.3 HTTP API认证协议

**服务地址**: `http://127.0.0.1:51234`

**认证头结构**:
```http
POST /v1/plugins/encode-msg HTTP/1.1
Content-Type: application/json
x-token: {认证Token}
X-Device: 1
x-id: {用户NIM ID}
x-group-token: {群Token}
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.87 Safari/537.36
Referer: http://127.0.0.1:51234/v1/plugins/encode-msg
Accept-Language: zh-cn
```

**Token格式**:
```
x-token: UOAGo3R73FEo7aMO_u6-pbt2DhBAx159dH02o4DM2CyuPclOUIzg3C-sri8y-rYQ...
         (Base64编码，约150-200字符)

x-group-token: hxV4WwoKi1uZ22apL5yDT0N0rGkv1EcagRjFlwHdpwD3DUm3MEBXXGmTS85b6fp3399751013
               (包含群ID的认证Token)
```

### 16.4 HTTP API端点清单

| 端点 | 方法 | 功能 | 请求体 |
|------|------|------|--------|
| `/v1/plugins/encode-msg` | POST | 编码消息 | JSON消息体 |
| `/v1/plugins/get-userinfo-by-id` | POST | ID互查 | `{"id":xxx,"type":0/1}` |
| `/v1/plugins/get-gid` | POST | 获取群信息 | `{"id":xxx,"type":2}` |
| `/v1/group/set-group-mute` | POST | 群禁言 | `{"groupId":xxx,"muteMode":"MUTE_ALL"}` |
| `/v1/plugins/user-group-info` | POST | 用户群信息 | `{"groupId":xxx}` |
| `/v1/user/login` | POST | 登录获取Token | `{"account":"","passwd":"","type":"LOGIN_TYPE_ACCOUNT_PWD"}` |
| `/v1/plugins/handle-relation-ask-friend` | POST | 处理好友请求 | `{"account":xxx,"type":1}` |
| `/v1/plugins/activation-code` | POST | 激活码验证 | 激活码信息 |
| `/ping` | GET | 心跳检测 | 无 |

### 16.5 Protobuf消息结构 (最底层二进制)

**消息二进制格式**:
```
偏移    字节    Protobuf标签    说明
────    ────    ──────────    ────
0x00    09      Field1        64-bit fixed (消息标识)
0x01-08 8字节   Value1        发送者ID + 时间序列
0x09    11      Field2        64-bit fixed (时间戳)
0x0A-11 8字节   Value2        Unix毫秒时间戳
0x12    19      Field3        64-bit fixed (加密种子)
0x13-1A 8字节   Value3        随机数/加密IV
0x1B    22      Field4        Length-delimited
0x1C    长度    Len           消息体长度(Varint)
0x1D+   N字节   Payload       AES加密的消息内容
```

**消息头示例**:
```hex
09-19-49-1F-01-A0-F8-43-02  // Field1: 消息ID
11-46-2E-63-69-00-00-00-00  // Field2: 时间戳
19-50-71-C7-E7-37-8C-5B-3F  // Field3: 加密种子
22-36-...                    // Field4: 加密消息体
```

### 16.6 NIM消息发送格式

**发送到NIM SDK的格式**:
```javascript
{
  msg: "{\"b\":\"Base64Protobuf\"}",
  TYPE: "1",        // "0"=私聊, "1"=群聊
  id: "40821608989", // 目标NIM ID (群tid或用户accid)
  msgid: "5c5bb391-eeaa-11f0-9f53-a3225e568098"  // UUID
}
```

**NIM发送成功响应**:
```json
{
  "anti_spam_res": "",
  "msg_id": "5c5bb391-eeaa-11f0-9f53-a3225e568098",
  "msg_id_server": 2739491805904148135,
  "msg_timetag": 1768107593847,
  "rescode": 200,
  "talk_id": "40821608989",
  "third_party_callback_ext": ""
}
```

### 16.7 NIM错误码表

| 错误码 | errno | 说明 |
|--------|-------|------|
| `-10261` | -236 | message error (消息错误) |
| `-10243` | 48 | no user id (无用户ID) |
| `401` | - | 无效token/登录失效 |
| `1001` | - | 业务逻辑错误 |
| `200` | - | 成功 |

### 16.8 完整消息接收结构

**NIM接收消息JSON**:
```json
{
  "content": {
    "client_msg_id": "707aa3e4-f85a-460f-b17a-a4224c8c227b",
    "cloud_history": 1,
    "from_client_type": 2,
    "from_device_id": "9AD9821C-C94B-4449-97B3-86A696FDBFC1",
    "from_id": "2092166259",
    "from_nick": "加密的昵称MD5",
    "is_force_push": 0,
    "log_status": 1,
    "log_sub_status": 0,
    "msg_attach": "{\"b\":\"Base64Protobuf消息体\"}",
    "msg_body": "",
    "msg_sub_type": 0,
    "msg_type": 100,
    "offline_msg": 1,
    "push_content": "",
    "push_enable": 1,
    "push_need_badge": 1,
    "push_prefix": 1,
    "res_id": "707aa3e4-f85a-460f-b17a-a4224c8c227b",
    "resend_flag": 0,
    "roam_msg": 1,
    "robot_info": {"account":"","content":"","function":"","topic":""},
    "routable_msg": 1,
    "server_ext": "",
    "server_msg_id": 2739491805904148285,
    "sync_msg": 1,
    "talk_id": "40821608989",
    "team_msg_ack": 0,
    "third_party_callback_ext": "",
    "time": 1768110547935,
    "to_accid": "40821608989",
    "to_type": 1,
    "update_account_id": "",
    "update_time": 0
  },
  "feature": 0,
  "rescode": 200
}
```

### 16.9 msg_type消息类型

| msg_type | 说明 |
|----------|------|
| 0 | 文本消息 |
| 1 | 图片消息 |
| 2 | 语音消息 |
| 3 | 视频消息 |
| 5 | 系统通知 (群信息变更等) |
| 100 | 自定义消息 (旺商聊业务消息) |

### 16.10 from_client_type设备类型

| from_client_type | 说明 |
|------------------|------|
| 2 | iOS |
| 4 | Android |
| 16 | Windows Desktop |
| 32 | Web/服务器 |

### 16.11 系统通知消息(msg_type=5)

**群信息变更通知**:
```json
{
  "data": {
    "name_cards": [...],
    "team_info": {
      "mute_all": 1,      // 1=全员禁言, 0=关闭
      "mute_type": 1,     // 禁言类型
      "tid": "40821608989",
      "update_timetag": 1768112829565
    }
  },
  "id": 3
}
```

### 16.12 底层Python实现

```python
"""
旺商聊最底层通信协议实现
"""

import socket
import json
import uuid
import base64
import struct
from typing import Optional, Dict, Tuple
from dataclasses import dataclass
from enum import IntEnum


class SessionType(IntEnum):
    """会话类型"""
    P2P = 0      # 私聊
    TEAM = 1     # 群聊


class MsgType(IntEnum):
    """消息类型"""
    TEXT = 0
    IMAGE = 1
    VOICE = 2
    VIDEO = 3
    NOTIFICATION = 5
    CUSTOM = 100


@dataclass
class NIMConfig:
    """NIM配置"""
    tcp_host: str = "127.0.0.1"
    tcp_port: int = 14745
    http_host: str = "127.0.0.1"
    http_port: int = 51234
    timeout: int = 10


class ProtobufBuilder:
    """Protobuf消息构建器"""
    
    @staticmethod
    def encode_varint(value: int) -> bytes:
        """编码Varint"""
        result = []
        while value > 127:
            result.append((value & 0x7F) | 0x80)
            value >>= 7
        result.append(value)
        return bytes(result)
    
    @staticmethod
    def encode_fixed64(value: int) -> bytes:
        """编码64位固定长度"""
        return struct.pack('<Q', value)
    
    @staticmethod
    def encode_length_delimited(data: bytes) -> bytes:
        """编码长度分隔字段"""
        return ProtobufBuilder.encode_varint(len(data)) + data
    
    @classmethod
    def build_message(cls, msg_id: int, timestamp: int, 
                      seed: int, payload: bytes) -> bytes:
        """
        构建完整Protobuf消息
        
        结构:
        Field1 (tag=0x09): 64-bit fixed - 消息ID
        Field2 (tag=0x11): 64-bit fixed - 时间戳
        Field3 (tag=0x19): 64-bit fixed - 加密种子
        Field4 (tag=0x22): length-delimited - 加密消息体
        """
        result = b''
        
        # Field 1: 消息ID (wire type 1 = 64-bit)
        result += bytes([0x09])  # tag: field=1, type=1
        result += cls.encode_fixed64(msg_id)
        
        # Field 2: 时间戳 (wire type 1 = 64-bit)
        result += bytes([0x11])  # tag: field=2, type=1
        result += cls.encode_fixed64(timestamp)
        
        # Field 3: 加密种子 (wire type 1 = 64-bit)
        result += bytes([0x19])  # tag: field=3, type=1
        result += cls.encode_fixed64(seed)
        
        # Field 4: 消息体 (wire type 2 = length-delimited)
        result += bytes([0x22])  # tag: field=4, type=2
        result += cls.encode_length_delimited(payload)
        
        return result


class NIMClient:
    """NIM底层客户端"""
    
    def __init__(self, config: NIMConfig = None):
        self.config = config or NIMConfig()
        self.sock = None
        
    def connect(self) -> bool:
        """连接TCP服务"""
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(self.config.timeout)
            self.sock.connect((self.config.tcp_host, self.config.tcp_port))
            return True
        except Exception as e:
            print(f"连接失败: {e}")
            return False
    
    def send_raw(self, command: str) -> str:
        """发送原始TCP命令"""
        if not self.sock:
            raise RuntimeError("未连接")
        
        # 添加换行符
        if not command.endswith('\n'):
            command += '\n'
        
        self.sock.send(command.encode('utf-8'))
        
        # 接收响应
        response = b''
        while True:
            try:
                chunk = self.sock.recv(4096)
                if not chunk:
                    break
                response += chunk
                if b'\n' in chunk or len(response) > 10000:
                    break
            except socket.timeout:
                break
        
        return response.decode('utf-8', errors='ignore')
    
    def send_group_message(self, robot_id: str, content: str, 
                          group_id: str) -> Dict:
        """
        发送群消息
        
        协议: 发送群消息（文本）|机器人号|内容|群号|1|0
        """
        content = content.replace('\n', '\\n')
        cmd = f"发送群消息（文本）|{robot_id}|{content}|{group_id}|1|0"
        
        response = self.send_raw(cmd)
        return self._parse_response(response)
    
    def send_private_message(self, robot_id: str, content: str,
                            target_id: str) -> Dict:
        """
        发送私聊消息
        
        协议: 发送好友消息|机器人号|内容|目标号
        """
        content = content.replace('\n', '\\n')
        cmd = f"发送好友消息|{robot_id}|{content}|{target_id}"
        
        response = self.send_raw(cmd)
        return self._parse_response(response)
    
    def group_mute(self, robot_id: str, group_id: str, mute: bool) -> Dict:
        """
        群禁言控制
        
        协议: ww_群禁言解禁|机器人号|群号|1或2
        1=禁言, 2=解禁
        """
        action = "1" if mute else "2"
        cmd = f"ww_群禁言解禁|{robot_id}|{group_id}|{action}"
        
        response = self.send_raw(cmd)
        return self._parse_response(response)
    
    def id_lookup(self, robot_id: str, target_id: str) -> Dict:
        """
        ID互查
        
        协议: ww_ID互查|机器人号|目标号
        """
        cmd = f"ww_ID互查|{robot_id}|{target_id}"
        
        response = self.send_raw(cmd)
        return self._parse_response(response)
    
    def get_online_accounts(self) -> Dict:
        """
        获取在线账号
        
        协议: 云信_获取在线账号
        """
        response = self.send_raw("云信_获取在线账号")
        return self._parse_response(response)
    
    def get_bind_groups(self, robot_id: str) -> Dict:
        """
        获取绑定群
        
        协议: 取绑定群|机器人号
        """
        cmd = f"取绑定群|{robot_id}"
        response = self.send_raw(cmd)
        return self._parse_response(response)
    
    def _parse_response(self, response: str) -> Dict:
        """解析响应"""
        result = {
            'success': False,
            'raw': response,
            'data': None,
            'error': None
        }
        
        # 查找返回结果
        if '返回结果:' in response:
            parts = response.split('返回结果:')
            if len(parts) > 1:
                b64_result = parts[1].strip().split('\n')[0]
                result['data'] = b64_result
                
                # 判断成功
                # 固定成功返回值
                if b64_result == "Dg15wK9Ua6C+fcRgZoN3NQ==":
                    result['success'] = True
                # 长Base64也可能是成功
                elif len(b64_result) > 50:
                    result['success'] = True
        
        # 检查JSON错误
        if '"code":' in response:
            try:
                import re
                json_match = re.search(r'\{[^}]+\}', response)
                if json_match:
                    error_json = json.loads(json_match.group())
                    if error_json.get('code') != 200:
                        result['error'] = error_json
            except:
                pass
        
        return result
    
    def close(self):
        """关闭连接"""
        if self.sock:
            self.sock.close()
            self.sock = None


class NIMMessageParser:
    """NIM消息解析器"""
    
    @staticmethod
    def parse_nim_response(json_str: str) -> Dict:
        """解析NIM响应JSON"""
        data = json.loads(json_str)
        
        content = data.get('content', {})
        
        return {
            'client_msg_id': content.get('client_msg_id'),
            'server_msg_id': content.get('server_msg_id'),
            'from_id': content.get('from_id'),
            'from_nick': content.get('from_nick'),
            'from_client_type': content.get('from_client_type'),
            'to_accid': content.get('to_accid'),
            'to_type': content.get('to_type'),
            'talk_id': content.get('talk_id'),
            'msg_type': content.get('msg_type'),
            'msg_sub_type': content.get('msg_sub_type'),
            'msg_attach': content.get('msg_attach'),
            'time': content.get('time'),
            'rescode': data.get('rescode'),
            'feature': data.get('feature')
        }
    
    @staticmethod
    def decode_msg_attach(msg_attach: str) -> Tuple[bytes, str]:
        """
        解码msg_attach中的消息体
        
        格式: {"b":"Base64Protobuf"}
        返回: (原始字节, 可读文本)
        """
        try:
            attach = json.loads(msg_attach)
            b_content = attach.get('b', '')
            
            if b_content:
                # URL-safe Base64 转标准Base64
                standard = b_content.replace('-', '+').replace('_', '/')
                
                # 补齐padding
                padding = 4 - (len(standard) % 4)
                if padding < 4:
                    standard += '=' * padding
                
                decoded = base64.b64decode(standard)
                
                # 尝试提取可读文本 (跳过Protobuf头部)
                text = ""
                if len(decoded) > 27:  # 头部约27字节
                    payload = decoded[27:]
                    text = payload.decode('utf-8', errors='ignore')
                
                return decoded, text
        except Exception as e:
            return b"", f"解码错误: {e}"
        
        return b"", ""


# HTTP API客户端
class HTTPAPIClient:
    """HTTP API客户端"""
    
    def __init__(self, host: str = "127.0.0.1", port: int = 51234):
        self.base_url = f"http://{host}:{port}"
        self.token = ""
        self.user_id = ""
        self.group_token = ""
    
    def set_auth(self, token: str, user_id: str, group_token: str = ""):
        """设置认证信息"""
        self.token = token
        self.user_id = user_id
        self.group_token = group_token
    
    def _get_headers(self) -> Dict:
        """获取请求头"""
        return {
            "Content-Type": "application/json",
            "x-token": self.token,
            "X-Device": "1",
            "x-id": self.user_id,
            "x-group-token": self.group_token,
            "User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36"
        }
    
    def encode_message(self, msg_json: Dict) -> Dict:
        """编码消息"""
        import urllib.request
        
        url = f"{self.base_url}/v1/plugins/encode-msg"
        data = json.dumps(msg_json).encode('utf-8')
        
        req = urllib.request.Request(url, data=data, headers=self._get_headers())
        
        try:
            with urllib.request.urlopen(req, timeout=10) as resp:
                return json.loads(resp.read().decode())
        except Exception as e:
            return {"error": str(e)}
    
    def set_group_mute(self, group_id: int, mute_mode: str) -> Dict:
        """
        设置群禁言
        
        mute_mode: "MUTE_ALL", "MUTE_MEMBER", "MUTE_NO"
        """
        import urllib.request
        
        url = f"{self.base_url}/v1/group/set-group-mute"
        data = json.dumps({
            "groupId": group_id,
            "muteMode": mute_mode
        }).encode('utf-8')
        
        req = urllib.request.Request(url, data=data, headers=self._get_headers())
        
        try:
            with urllib.request.urlopen(req, timeout=10) as resp:
                return json.loads(resp.read().decode())
        except Exception as e:
            return {"error": str(e)}
    
    def get_userinfo_by_id(self, target_id: int, id_type: int) -> Dict:
        """
        ID互查
        
        id_type: 0=NIM转旺商聊, 1=旺商聊转NIM, 2=群ID
        """
        import urllib.request
        
        url = f"{self.base_url}/v1/plugins/get-userinfo-by-id"
        data = json.dumps({
            "id": target_id,
            "type": id_type
        }).encode('utf-8')
        
        req = urllib.request.Request(url, data=data, headers=self._get_headers())
        
        try:
            with urllib.request.urlopen(req, timeout=10) as resp:
                return json.loads(resp.read().decode())
        except Exception as e:
            return {"error": str(e)}


# 使用示例
if __name__ == '__main__':
    # 创建NIM客户端
    client = NIMClient()
    
    if client.connect():
        print("连接成功!")
        
        # 获取在线账号
        result = client.get_online_accounts()
        print(f"在线账号: {result}")
        
        # 发送群消息
        result = client.send_group_message(
            robot_id="621705120",
            content="测试消息",
            group_id="3962369093"
        )
        print(f"发送结果: {result}")
        
        client.close()
```

### 16.13 端口监听状态

```
TCP 0.0.0.0:14745       LISTENING   xplugin主服务
TCP 127.0.0.1:14745     LISTENING   本地API服务
TCP 127.0.0.1:51234     LISTENING   HTTP API服务
```

### 16.14 完整协议流程图

```
用户调用
   │
   ▼
┌──────────────────────────────────────────┐
│ 1. TCP发送命令                            │
│    发送群消息（文本）|621705120|...|1|0    │
│    端口: 14745                            │
└───────────────┬──────────────────────────┘
                │
                ▼
┌──────────────────────────────────────────┐
│ 2. xplugin解析命令                        │
│    提取: 机器人号, 内容, 群号, 类型        │
└───────────────┬──────────────────────────┘
                │
                ▼
┌──────────────────────────────────────────┐
│ 3. HTTP API调用                           │
│    POST /v1/plugins/encode-msg            │
│    携带: x-token, x-id, x-group-token     │
│    端口: 51234                            │
└───────────────┬──────────────────────────┘
                │
                ▼
┌──────────────────────────────────────────┐
│ 4. Protobuf编码                           │
│    Field1: 消息ID (64-bit)                │
│    Field2: 时间戳 (64-bit)                │
│    Field3: 加密种子 (64-bit)              │
│    Field4: AES加密消息体                  │
└───────────────┬──────────────────────────┘
                │
                ▼
┌──────────────────────────────────────────┐
│ 5. NIM SDK发送                            │
│    {msg:"...",TYPE:"1",id:"tid",msgid:""}│
│    调用: nim.dll                          │
└───────────────┬──────────────────────────┘
                │
                ▼
┌──────────────────────────────────────────┐
│ 6. 云信服务器响应                          │
│    {"rescode":200,"msg_id_server":xxx}    │
└───────────────┬──────────────────────────┘
                │
                ▼
┌──────────────────────────────────────────┐
│ 7. 返回Base64结果                         │
│    返回结果:Dg15wK9Ua6C+fcRgZoN3NQ==      │
│    (16字节固定成功标识)                   │
└──────────────────────────────────────────┘
```

---

*文档版本: 1.4*
*更新: 添加最底层Protobuf/HTTP API/NIM通信协议*
*完整解析从TCP命令到云信服务器的全链路*
*基于实际抓包和二进制分析*
