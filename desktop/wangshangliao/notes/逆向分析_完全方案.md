# 旺商聊完全逆向分析报告

## 一、关键发现

### 1. xclient.node 是核心
经过深度分析发现，**xclient.node 是 Node.js 原生模块**，不是独立进程：

```
┌─────────────────────────────────────────────────────────┐
│              Electron Main Process                      │
│  ┌───────────┐    ┌───────────────┐    ┌────────────┐  │
│  │  Node.js  │───▶│ xclient.node  │───▶│ NIM服务器  │  │
│  │           │    │ (C++ Native)  │    │            │  │
│  └───────────┘    └───────────────┘    └────────────┘  │
└─────────────────────────────────────────────────────────┘
                          │
                     bindings()
                          │
              ┌───────────┴───────────┐
              │    导出函数           │
              │  - xinit(key)         │
              │  - xtask(...)         │
              │  - xsync(...)         │
              └───────────────────────┘
```

### 2. xclient.exe 是辅助进程
- 端口 21303 只是一个本地服务
- 可能用于认证/许可证验证
- **不是主要通信通道**

### 3. 真正的通信路径
```
JavaScript (渲染进程)
    │
    │ ipcRenderer.send("xclient", {...})
    ▼
Electron IPC
    │
    │ ipcMain.on("xclient", ...)
    ▼
XClientServer类 (主进程)
    │
    │ this.x.xtask() / this.x.xsync()
    ▼
xclient.node (C++ Native Module)
    │
    │ HTTP/HTTPS 或 WebSocket
    ▼
NIM云信服务器 (43.159.95.211)
```

## 二、xclient.node 功能分析

### 导出的函数
从 napi 分析得到 3 个核心函数：

```javascript
// 1. 初始化 - 传入环境密钥
xinit(key: string): void

// 2. 异步任务 - API请求、加密、广播等
xtask(excuteType: number, unknown: number, action: string, params: string | null, buffer?: ArrayBuffer): Promise<any>

// 3. 同步调用 - 主要用于解码
xsync(type: number, data: ArrayBuffer): any
```

### xtask 参数详解
```javascript
// excuteType:
//   0 = 普通请求
//   1 = 特殊操作 (buildin, encrypt, broadcast)
//   2 = 登录请求

// action 值:
//   API URL (如 "/v1/group/get-group-list")
//   "buildin"  - 内置命令
//   "encrypt"  - 加密消息
//   "broadcast" - 广播消息

// params:
//   JSON字符串或null

// buffer:
//   用于加密时传入的二进制数据
```

## 三、完全逆向方案

### 方案A: 加载 xclient.node (推荐)

直接在 C# 中加载 xclient.node 原生模块：

```csharp
// 使用 P/Invoke 或 EdgeJS 加载 xclient.node
public class XClientNative
{
    // 通过 Node.js 运行时加载
    private dynamic xclient;
    
    public void Init(string key)
    {
        // 加载 xclient.node
        xclient = require("./xclient.node");
        xclient.xinit(key);
    }
    
    public async Task<dynamic> Request(string url, string params)
    {
        return await xclient.xtask(0, 0, url, params);
    }
}
```

**优点**: 
- 使用官方加密/通信逻辑
- 兼容性最好
- 不需要逆向协议

**缺点**:
- 依赖 Node.js 运行时
- xclient.node 可能有完整性校验

### 方案B: 逆向 xclient.node (已部分完成)

分析 xclient.node 的二进制实现：

1. **加密算法**: AES-256-GCM (已实现)
2. **消息格式**: Protobuf (已实现)
3. **密钥派生**: HKDF (已实现)
4. **网络协议**: 需要进一步分析

### 方案C: 直接连接 NIM 服务器 (最复杂)

绕过 xclient，直接与 NIM 云信服务器通信：

```
需要逆向:
1. NIM SDK 的认证协议
2. WebSocket 消息格式
3. 加密/签名算法
4. 会话管理
```

## 四、已创建的文件

| 文件 | 说明 | 完成度 |
|------|------|--------|
| `WslCrypto.cs` | AES-256-GCM 加密/解密 | 100% |
| `WslProtobuf.cs` | Protobuf 编解码 | 100% |
| `WslTcpProtocol.cs` | TCP 协议框架 | 80% |
| `WslPureClient.cs` | 客户端 API | 80% |
| `WslPureClientTest.cs` | 测试程序 | 100% |

## 五、密钥结构详解

### Production 环境密钥
```
Part1 (104 bytes):
  版本: 1
  数据: AppKey + 认证数据
  Hex头: 01 00 00 00 00 00 00 00 55 66 94 46...

Part2 (104 bytes):
  版本: 5  
  数据: Token + 会话数据
  Hex头: 05 00 00 00 00 00 00 00 ED 7D 14 D5...

Part3 (385 bytes):
  加密密钥 + 签名数据
  Hex头: 45 C4 46 C4 49 C5 7C 58 11 CC D9 20...
```

## 六、下一步建议

1. **短期方案**: 使用 CDP 注入 JavaScript 调用现有 API
2. **中期方案**: 尝试通过 Edge.js 加载 xclient.node
3. **长期方案**: 完全逆向 xclient.node 的网络协议

## 七、技术栈总结

| 组件 | 技术 |
|------|------|
| 加密 | AES-256-GCM |
| 消息序列化 | Protobuf |
| 密钥派生 | HKDF-SHA256 |
| 网络 | HTTP/WebSocket over TLS |
| 原生模块 | Node-API (N-API) |

---

*分析完成时间: 2026-01-10*
